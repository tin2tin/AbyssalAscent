<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Abyssal Ascent - Mellow Echoes</title>
    <style>
        html {
            height: 100%;
            touch-action: none; /* Global prevention of default touch actions */
        }
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100%; /* Fill html */
            background: #000000;
            overflow: hidden;
            font-family: sans-serif;
            user-select: none;
        }
        #game-super-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            width: 100%;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            border: 2px solid #00111a;
            background: #000000;
            display: block;
            aspect-ratio: 600 / 900;
            object-fit: contain;
            touch-action: none;
        }
        #top-right-controls { position: absolute; top: 10px; right: 10px; left: auto; z-index: 100; display: none; }
        #pause-button { padding: 8px 15px; background: linear-gradient(to bottom, #4A6B7E, #3A5060); border: 2px solid #1C2A34; border-radius: 5px; color: white; cursor: pointer; font-family: sans-serif; font-size: 16px; white-space: nowrap; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); user-select: none; touch-action: manipulation; }
        #pause-button:active { background: linear-gradient(to bottom, #3A5060, #4A6B7E); box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5); }

        #mobile-controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 10;
        }
        #mobile-controls {
            display: none; /* Controlled by JS */
            width: 100%;
            max-width: 600px; /* Limit width on larger screens, content will be space-between */
            margin: 0 auto; /* Center the controls bar */
            padding: 10px 5px; /* Padding around the controls area */
            box-sizing: border-box;
            justify-content: space-between; /* Key for positioning groups */
            align-items: flex-end; /* Align buttons to the bottom of their line */
        }
        #mobile-controls .control-group {
            display: flex;
            gap: 15px; /* Adjusted gap between L/R buttons */
        }
        #mobile-controls button {
            width: 80px; /* Adjusted size */
            height: 80px; /* Adjusted size */
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #20B2AA, #008080);
            border: 2px solid #004D40;
            border-radius: 50%;
            color: white;
            font-size: 16px; /* Adjusted font size */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            user-select: none;
            touch-action: manipulation;
            text-align: center;
            line-height: 1; /* Assumes single word, fits */
        }
        #mobile-controls button:active {
            background: linear-gradient(to bottom, #008080, #20B2AA);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5);
        }

        #pause-menu { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,10,20,0.9); z-index: 200; flex-direction: column; justify-content: center; align-items: center; color: #E0F7FA; font-size: 24px; }
        #pause-menu h2 { font-size: 4em; margin-bottom: 30px; color: #FFEB3B; text-shadow: 2px 2px 5px rgba(0,0,0,0.7); }
        #pause-menu button { padding: 15px 30px; margin: 10px 0; font-size: 1.5em; background: linear-gradient(to bottom, #20B2AA, #008080); border: 2px solid #004D40; border-radius: 8px; color: white; cursor: pointer; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); user-select: none; touch-action: manipulation; }
        #pause-menu button:active { background: linear-gradient(to bottom, #008080, #20B2AA); box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5); }
        #close-app-button { background: linear-gradient(to bottom, #E57373, #C62828) !important; }
        #close-app-button:active { background: linear-gradient(to bottom, #C62828, #E57373) !important; }
    </style>
</head>
<body>
    <div id="game-super-container">
        <div id="top-right-controls"><button id="pause-button">PAUSE</button></div>
        <canvas id="gameCanvas"></canvas>
        <div id="mobile-controls-container">
            <div id="mobile-controls">
                <div class="control-group">
                    <button id="left-btn">LEFT</button>
                    <button id="right-btn">RIGHT</button>
                </div>
                <button id="jump-btn">PUSH</button>
            </div>
        </div>
    </div>
    <div id="pause-menu">
        <h2>PAUSED</h2>
        <button id="resume-button">Resume Ascent</button>
        <button id="restart-from-pause">New Ascent</button>
        <button id="mute-button-from-pause">Mute Echoes</button>
        <button id="close-app-button">Return to Surface</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const TARGET_CANVAS_WIDTH = 600; const TARGET_CANVAS_HEIGHT = 900;
        canvas.width = TARGET_CANVAS_WIDTH; canvas.height = TARGET_CANVAS_HEIGHT;
        const isAndroid = /Android/i.test(navigator.userAgent);
        
        const gameSpeedFactor = isAndroid ? 0.5 : 1.0;

        const BUOYANCY = -0.12 * gameSpeedFactor; 
        const PLAYER_BASE_SPEED = 2.6 * gameSpeedFactor; 
        const PLAYER_BASE_PUSH_INITIAL = 9.0 * gameSpeedFactor; 
        const WATER_RESISTANCE_V = 0.97;
        const WATER_RESISTANCE_H_NORMAL = 0.96;
        const WATER_RESISTANCE_H_SLIPPERY = 0.992; 
        const PLATFORM_ATTACH_PULL_UP = 0.30 * gameSpeedFactor; 

        const MIN_CEILING_UNDERSIDE_GAP_FACTOR = 0.35;
        const MAX_CEILING_UNDERSIDE_GAP_FACTOR = 0.40; 

        const BOTTOM_DEATH_FLOOR_HEIGHT = 20;
        const EXIT_CEILING_HEIGHT = 25; const TOP_SURFACE_DEATH_Y = 10;
        const EXIT_CEILING_UNDERSIDE_Y = TOP_SURFACE_DEATH_Y + EXIT_CEILING_HEIGHT + 25;
        const PLATFORM_CORNER_RADIUS = 10;
        const STARTING_DEPTH = 1000; const DEPTH_DECREASE_PER_LEVEL = 7;

        const keys = {};
        window.addEventListener('keydown', e => { /* ... (original key listener) ... */ keys[e.key] = true; const keyLower = e.key.toLowerCase(); if (keyLower === ' ') { if (gameState !== 'playing' && gameState !== 'paused') { e.preventDefault(); } } else if (keyLower === 'p' || keyLower === 'escape') { if (gameState === 'playing' || gameState === 'gameOver' || gameState === 'gameWon') { e.preventDefault(); } } });
        window.addEventListener('keyup',e=>keys[e.key]=false);

        const topRightControls=document.getElementById('top-right-controls');const mobileControls=document.getElementById('mobile-controls');const pauseMenu=document.getElementById('pause-menu');const pauseButton=document.getElementById('pause-button');const resumeButton=document.getElementById('resume-button');const closeAppButton=document.getElementById('close-app-button');const restartFromPauseButton=document.getElementById('restart-from-pause');const muteButtonFromPause=document.getElementById('mute-button-from-pause');const leftBtn=document.getElementById('left-btn');const rightBtn=document.getElementById('right-btn');const jumpBtn=document.getElementById('jump-btn');

        let player={x:50,y:50,radius:15,baseRadius:15,maxRadius:26,radiusGrowthPerStar:0.25,vx:0,vy:0,isAttached:false,lives:3,scale:1,canTakeDamage:true,damageCooldownTimeout:null,invincible:false,invincibleTimer:0,speedBoost:false,speedBoostTimer:0,baseSpeed:PLAYER_BASE_SPEED,currentPushForce: PLAYER_BASE_PUSH_INITIAL,attachedPlatform:null, sonarPulseActive: false, sonarPulseTimer: 0, sonarPulseRadius: 0, sonarPulseMaxRadius: 150, sonarPulseCount: 0, inkedTimer: 0};
        let platforms=[];let enemies=[];let stars=[];let powerUps=[];let gameEffectParticles=[];
        let strongCurrents = [];
        let ambientBubbles=[]; let foregroundBubbles = [];
        let seaFloorKelps = []; 
        let exitPlatform=null;
        let airCollected=0; let internalLevel=1; let currentDepth = STARTING_DEPTH;
        let gameState='start';
        let platformBaseSpeed = 0.42 * gameSpeedFactor; 
        let currentGradientColors=['#000000','#000000','#000000']; let gradientBaseHue = 200;
        let totalAirHighScore=parseInt(localStorage.getItem('abyssalAscentTotalAir_v22')||'0',10); // Version bump
        let gameOverFinalAir=0;let transitionAlpha=0;let transitionSpeed=0.03;let transitionCallback=null;let playerCanMove=false;let gameOver=false; let justRestartedFromGameOver = false;
        const SPECIAL_PLATFORM_TYPES=['disappearing_coral','bouncy_vent','conveyor_current', 'retracting_coral', 'slippery_kelp_patch'];
        const PLATFORM_VISUAL_THEMES = ['rock_formation', 'ancient_coral_shelf', 'dense_kelp_bed', 'sunken_driftwood', 'rusted_shipwreck_panel', 'industrial_grate'];
        let seaFloorDecorations = [];

        function updateUI(){} // This function is empty in original, can be used if needed
        function updateUIVisibility(){ 
            const showMobile = isAndroid && (gameState==='start'||gameState==='playing'||gameState==='gameOver'||gameState==='gameWon'||gameState==='transitioning');
            mobileControls.style.display = showMobile ? 'flex' : 'none';
            
            if(gameState==='start'||gameState==='gameOver'||gameState==='gameWon'){
                topRightControls.style.display='block';
                pauseMenu.style.display='none';
            } else if(gameState==='playing'||gameState==='transitioning'){
                topRightControls.style.display='block';
                pauseMenu.style.display='none';
            } else if(gameState==='paused'){
                topRightControls.style.display='none';
                pauseMenu.style.display='flex';
            }
        }
        let audioContext;let abyssalDroneMusic;let cyclingPlatformsMusic;let isMuted=false;
        
        const BASE_SFX_VOL = 0.18 * 0.7; 

        function createOscillatorSound(f,duration,t,pStartTime=0, vol = BASE_SFX_VOL, attackTime=0.001, decayTime=0.1, sustainLevel=0.001) { 
            if(isMuted)return; 
            if(gameState!=='playing'&&gameState!=='levelComplete'&&gameState!=='gameWon'&&gameState!=='start')return; 
            if(!isFinite(f)||!isFinite(duration)||!isFinite(pStartTime)){console.error("Non-finite audio param:",{f,duration,pStartTime});return;} 
            if(!audioContext){try{audioContext=new(window.AudioContext||window.webkitAudioContext)();}catch(e){console.warn("No AudioCtx");return;}} 
            if(!audioContext)return; 
            const actualStartTime=audioContext.currentTime+pStartTime; 
            const osc=audioContext.createOscillator();const gain=audioContext.createGain(); 
            osc.type=t; 
            osc.frequency.setValueAtTime(f,actualStartTime); 
            gain.gain.setValueAtTime(0, actualStartTime); 
            gain.gain.linearRampToValueAtTime(vol, actualStartTime + attackTime); 
            gain.gain.setValueAtTime(vol, actualStartTime + duration - decayTime); 
            gain.gain.linearRampToValueAtTime(sustainLevel, actualStartTime + duration); 
            osc.connect(gain);gain.connect(audioContext.destination); 
            osc.start(actualStartTime);osc.stop(actualStartTime+duration + 0.05); 
        }
        
        function playPushFromCeilingSound(){ createOscillatorSound(80, 0.25, 'sine', 0, BASE_SFX_VOL * 1.1, 0.01, 0.2); createOscillatorSound(100, 0.15, 'square', 0.02, BASE_SFX_VOL * 0.6, 0.01, 0.1); emitParticles(player.x,player.y-player.radius,'push_down_burst');}
        function playAttachToCeilingSound(){ createOscillatorSound(250, 0.15, 'sine', 0, BASE_SFX_VOL * 0.8, 0.02, 0.1); createOscillatorSound(150, 0.1, 'triangle', 0.03, BASE_SFX_VOL * 0.6, 0.01, 0.08); emitParticles(player.x,player.y-player.radius,'attach_clink');}
        function playGemSound(){ 
            if (audioContext) { 
                const now = audioContext.currentTime; 
                const noiseOsc = audioContext.createOscillator(); 
                const noiseGain = audioContext.createGain(); 
                noiseOsc.type = 'sine'; 
                noiseOsc.frequency.setValueAtTime(1200, now); 
                noiseOsc.frequency.exponentialRampToValueAtTime(300, now + 0.15); 
                noiseGain.gain.setValueAtTime(0.001, now); 
                noiseGain.gain.linearRampToValueAtTime(BASE_SFX_VOL * 0.55, now + 0.02); 
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.18); 
                noiseOsc.connect(noiseGain); noiseGain.connect(audioContext.destination); 
                noiseOsc.start(now); noiseOsc.stop(now + 0.2); 
            } 
            createOscillatorSound(700, 0.1, 'sine', 0.08, BASE_SFX_VOL * 0.45, 0.005, 0.09); 
            emitParticles(player.x,player.y,'gem_shine');
        }
        function playBouncyVentSound(){ createOscillatorSound(150, 0.35, 'sine', 0, BASE_SFX_VOL * 1.1, 0.05, 0.25); createOscillatorSound(600, 0.2, 'triangle', 0.05, BASE_SFX_VOL * 0.6, 0.02, 0.15); emitParticles(player.x,player.y-player.radius,'geyser_burst');}
        function playLifeLostSound(){ createOscillatorSound(70, 0.5, 'sine', 0, BASE_SFX_VOL * 1.4, 0.05, 0.4); createOscillatorSound(90, 0.4, 'square', 0.1, BASE_SFX_VOL * 0.8, 0.05, 0.3);}
        function playLevelCompleteSound(){ createOscillatorSound(330, 0.25, 'sine', 0, BASE_SFX_VOL * 0.8, 0.03, 0.2); createOscillatorSound(440, 0.25, 'sine', 0.15, BASE_SFX_VOL * 0.8, 0.03, 0.2); createOscillatorSound(523.25, 0.25, 'sine', 0.3, BASE_SFX_VOL * 0.8, 0.03, 0.2);}
        function playGameOverSound(){ createOscillatorSound(150, 0.6, 'sine', 0, BASE_SFX_VOL * 1.1, 0.1, 0.45); createOscillatorSound(75, 0.7, 'sine', 0.2, BASE_SFX_VOL, 0.1, 0.55);}
        function playPowerUpSound(type){ 
            let baseFreq = 300, secondFreq = 400, waveform = 'triangle', dur = 0.25, vol = BASE_SFX_VOL * 0.8; 
            if(type==='extra_life') { baseFreq=500; secondFreq=650; waveform='sine'; dur=0.35; vol=BASE_SFX_VOL;} 
            else if (type === 'sonar_pulse') { baseFreq=200; secondFreq=100; waveform='sine'; dur=0.4; vol=BASE_SFX_VOL * 1.1;} 
            createOscillatorSound(baseFreq, dur, waveform, 0, vol, 0.02, dur*0.8); 
            if (type !== 'sonar_pulse') createOscillatorSound(secondFreq, dur, waveform, 0.05, vol*0.7, 0.02, dur*0.8); 
        } 
        function playGameWonSound(){ createOscillatorSound(392, 0.3, 'sine', 0, BASE_SFX_VOL, 0.05, 0.25); createOscillatorSound(523.25, 0.3, 'sine', 0.15, BASE_SFX_VOL, 0.05, 0.25); createOscillatorSound(659.25, 0.35, 'sine', 0.3, BASE_SFX_VOL, 0.05, 0.3); }
        function playJellyfishBounceSound(){ 
            createOscillatorSound(180, 0.25, 'sine', 0, BASE_SFX_VOL * 1.2, 0.01, 0.2); 
            if(!audioContext) return; const osc = audioContext.createOscillator(); const gain = audioContext.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(280, audioContext.currentTime); osc.frequency.exponentialRampToValueAtTime(120, audioContext.currentTime + 0.20); 
            gain.gain.setValueAtTime(BASE_SFX_VOL * 0.8, audioContext.currentTime); 
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.20); osc.connect(gain); gain.connect(audioContext.destination); osc.start(); osc.stop(audioContext.currentTime + 0.21);
        }
        function playJellyfishPushedSound(){ createOscillatorSound(100, 0.25, 'sine', 0, BASE_SFX_VOL * 0.8, 0.02, 0.2); createOscillatorSound(150, 0.15, 'square', 0.03, BASE_SFX_VOL * 0.45, 0.01, 0.1); }
        function playLurkerWarningSound(){ createOscillatorSound(120, 0.2, 'sawtooth', 0, BASE_SFX_VOL * 0.7, 0.01, 0.18); createOscillatorSound(100, 0.15, 'square', 0.05, BASE_SFX_VOL * 0.6, 0.01, 0.13);}
        function playLurkerChargeSound(){ createOscillatorSound(100, 0.5, 'sine', 0, BASE_SFX_VOL * 0.8, 0.1, 0.4); createOscillatorSound(150, 0.45, 'triangle', 0.05, BASE_SFX_VOL * 0.6, 0.08, 0.35); } 
        function playLurkerImpactSound(){ createOscillatorSound(80, 0.25, 'sine', 0, BASE_SFX_VOL * 1.1, 0.01, 0.2); createOscillatorSound(120, 0.15, 'square', 0.02, BASE_SFX_VOL * 0.7, 0.01, 0.1); emitParticles(player.x, player.y, 'lurker_ink_splat');} 
        function playRetractPlatformSound(){ createOscillatorSound(150, 0.35, 'sawtooth', 0, BASE_SFX_VOL * 0.8, 0.05, 0.25); createOscillatorSound(100, 0.3, 'square', 0.08, BASE_SFX_VOL * 0.6, 0.05, 0.2); } 
        function playSonarPulseFireSound(){ createOscillatorSound(300, 0.3, 'sine', 0, BASE_SFX_VOL * 1.2, 0.01, 0.25); }

        muteButtonFromPause.addEventListener('click',toggleMute);function toggleMute(){ isMuted=!isMuted;muteButtonFromPause.textContent=isMuted?'Unmute Sounds':'Mute Sounds';if(abyssalDroneMusic){abyssalDroneMusic.muted=isMuted;if(isMuted&&!abyssalDroneMusic.paused)abyssalDroneMusic.pause();}if(cyclingPlatformsMusic){cyclingPlatformsMusic.muted=isMuted;if(isMuted&&!cyclingPlatformsMusic.paused)cyclingPlatformsMusic.pause();}if(!isMuted&&(gameState==='playing'||gameState==='start'||gameState==='gameWon')){attemptPlayMusic();}}
        function prepareMusic(){ if(!abyssalDroneMusic){try{abyssalDroneMusic=new Audio('audio/Abyssal_Drone.mp3');abyssalDroneMusic.loop=true;abyssalDroneMusic.volume=0.3;abyssalDroneMusic.muted=isMuted;}catch(e){console.warn("No drone music",e);abyssalDroneMusic=null;}}if(!cyclingPlatformsMusic){try{cyclingPlatformsMusic=new Audio('audio/Cycling_Platforms.mp3');cyclingPlatformsMusic.loop=true;cyclingPlatformsMusic.volume=0.25;cyclingPlatformsMusic.muted=isMuted;}catch(e){console.warn("No cycling music",e);cyclingPlatformsMusic=null;}}}
        function attemptPlayMusic(){ prepareMusic();if(abyssalDroneMusic&&!isMuted&&abyssalDroneMusic.paused){abyssalDroneMusic.play().catch(e=>console.error("Drone Music fail:",e));}if(cyclingPlatformsMusic&&!isMuted&&cyclingPlatformsMusic.paused){cyclingPlatformsMusic.play().catch(e=>console.error("Cycling Music fail:",e));}}
        
        setupTouchControl(leftBtn,'ArrowLeft');setupTouchControl(rightBtn,'ArrowRight');setupTouchControl(jumpBtn,' ');
        function setupTouchControl(btn,key){ 
            btn.addEventListener('touchstart',(e)=>{e.preventDefault();keys[key]=true;if(key===' '&&gameState==='start'){attemptPlayMusic();gameState='playing';playerCanMove=true;updateUIVisibility();keys[' ']=false;}else if(key===' '&&(gameState==='gameOver'||gameState==='gameWon')){attemptPlayMusic();resetGame(true);keys[' ']=false;justRestartedFromGameOver=true;}},{passive:false});
            btn.addEventListener('touchend',(e)=>{e.preventDefault();keys[key]=false;},{passive:false});
            btn.addEventListener('mousedown',()=>{keys[key]=true;if(key===' '&&gameState==='start'){attemptPlayMusic();gameState='playing';playerCanMove=true;updateUIVisibility();keys[' ']=false;}else if(key===' '&&(gameState==='gameOver'||gameState==='gameWon')){attemptPlayMusic();resetGame(true);keys[' ']=false;justRestartedFromGameOver=true;}});
            btn.addEventListener('mouseup',()=>{keys[key]=false;});
            btn.addEventListener('mouseleave',()=>{keys[key]=false;});
        }
        pauseButton.addEventListener('click', () => { if (gameState === 'playing') { gameState = 'paused'; if (abyssalDroneMusic) abyssalDroneMusic.pause(); if (cyclingPlatformsMusic) cyclingPlatformsMusic.pause(); playerCanMove = false; updateUIVisibility(); } else if (gameState === 'gameOver' || gameState === 'gameWon') { attemptPlayMusic(); resetGame(true); } });
        resumeButton.addEventListener('click',()=>{ if(gameState==='paused'){gameState='playing';attemptPlayMusic();playerCanMove=true;updateUIVisibility();}});
        restartFromPauseButton.addEventListener('click',()=>{ if(gameState==='paused'||confirm("New Ascent? This will reset your Air Collected and current Depth.")){resetGame(true);}});
        closeAppButton.addEventListener('click',()=>{ if(window.AndroidInterface&&typeof window.AndroidInterface.closeApp==='function'){window.AndroidInterface.closeApp();}else{alert("Cannot close.");}});

        class GameEffectParticle{ constructor(x,y,type,color,size,vx,vy,lifetime){this.x=x;this.y=y;this.type=type;this.color=color;this.size=size;this.vx=vx*gameSpeedFactor;this.vy=vy*gameSpeedFactor;this.alpha=1;this.lifetime=lifetime/gameSpeedFactor;this.originalLifetime=this.lifetime;this.buoyancyEffect=(type==='push_down_burst'||type==='geyser_burst')?0.09*gameSpeedFactor:((type==='attach_clink')?0.03*gameSpeedFactor:-0.06*gameSpeedFactor); if(type==='lurker_ink_cloud') this.buoyancyEffect = (Math.random()-0.5) * 0.02; if(type==='lurker_ink_splat') this.buoyancyEffect = -0.03;} update(){this.x+=this.vx;this.y+=this.vy;this.vy+=this.buoyancyEffect;this.vy*=0.98;this.vx*=0.98;this.lifetime--;this.alpha=this.lifetime/this.originalLifetime;this.size*=(this.type==='gem_shine'||this.type==='lurker_ink_splat'||this.type==='lurker_ink_cloud'?0.97:0.93);if(this.lifetime<=0||this.size<0.2)this.lifetime=0;} draw(ctx){if(this.lifetime<=0)return;ctx.save();ctx.globalAlpha=this.alpha;ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fill();ctx.restore();}}
        function emitParticles(x,y,type, targetX, targetY){  let numP,clr,minS,maxS,minVx,maxVx,minVy,maxVy,life; switch(type){ case 'gem_shine':numP=6;clr='rgba(200,255,255,0.9)';minS=2;maxS=5;minVx=-1.5;maxVx=1.5;minVy=-1.5;maxVy=1.5;life=35;break; case 'attach_clink':numP=4;clr='rgba(160,160,160,0.5)';minS=3;maxS=6;minVx=-0.5;maxVx=0.5;minVy=0.1;maxVy=0.4;life=25;break; case 'push_down_burst':numP=8;clr='rgba(130,180,235,0.65)';minS=4;maxS=8;minVx=-1.2;maxVx=1.2;minVy=2.5;maxVy=4.5;life=40;break; case 'geyser_burst':numP=12;clr='rgba(180,235,210,0.75)';minS=5;maxS=10;minVx=-1.5;maxVx=1.5;minVy=3.0;maxVy=5.5;life=45;break; case 'lurker_ink_cloud': numP = 3; clr = `rgba(${20 + Math.random()*20},${20 + Math.random()*20},${25 + Math.random()*20},${0.5 + Math.random()*0.3})`; minS = 8; maxS = 15; life = 45; minVx = (Math.random() - 0.5) * 1.5; maxVx = (Math.random() - 0.5) * 1.5; minVy = (Math.random() - 0.5) * 1.5; maxVy = (Math.random() - 0.5) * 1.5; break; case 'lurker_ink_splat': numP=15; clr='rgba(30,30,35,0.8)'; minS=3; maxS=7; minVx=-2.5; maxVx=2.5; minVy=-2.5; maxVy=2.5; life=30; break; default:return;} for(let i=0;i<numP;i++){gameEffectParticles.push(new GameEffectParticle(x+(Math.random()-0.5)*5,y+(Math.random()-0.5)*5,type,clr,minS+Math.random()*(maxS-minS),minVx+Math.random()*(maxVx-minVx),minVy+Math.random()*(maxVy-minVy),life));}}
        class AmbientBubble { constructor(isParallaxLayer, type = 'ambient') { this.isParallax = isParallaxLayer; this.type = type; this.reset(); } reset() { if (this.type === 'foreground') { this.radius = 25 + Math.random() * 25; this.x = Math.random() * TARGET_CANVAS_WIDTH; this.y = Math.random() * TARGET_CANVAS_HEIGHT; this.baseSpeedY = -(0.1 + Math.random() * 0.15) * gameSpeedFactor; this.speedY = this.baseSpeedY; this.speedX = (Math.random() - 0.5) * 0.1 * gameSpeedFactor; this.alpha = 0.04 + Math.random() * 0.06; this.color = `rgba(200, 235, 255, ${this.alpha})`; this.isParallax = true; } else { this.radius = this.isParallax ? (3 + Math.random() * 7) : (2 + Math.random() * 4); this.x = Math.random() * TARGET_CANVAS_WIDTH; this.y = Math.random() * (TARGET_CANVAS_HEIGHT * 1.2); this.baseSpeedY = -(this.isParallax ? (0.35 + Math.random() * 0.65) : (0.9 + Math.random() * 2.0)) * gameSpeedFactor; this.speedY = this.baseSpeedY; this.speedX = (Math.random() - 0.5) * (this.isParallax ? 0.25 : 0.45) * gameSpeedFactor; this.alpha = (this.isParallax ? 0.05 : 0.2) + Math.random() * (this.isParallax ? 0.18 : 0.35); this.color = `rgba(170, 220, 255, ${this.alpha})`; } this.stuckTimer = 0; this.platformInfluenceX = 0; } update() { this.y += this.speedY; this.x += this.speedX + this.platformInfluenceX; this.platformInfluenceX *= 0.85; this.speedY *= 0.998; this.speedX *= 0.99; if (this.y < -this.radius * 3) { this.reset(); } if (this.type === 'ambient' && !this.isParallax && this.stuckTimer <= 0) { for (const p of platforms) { if (p.deadly || p.type === 'ocean_floor') continue; const pTop = p.y; const pBottom = p.y + p.height; const pLeft = p.x; const pRight = p.x + p.width; if (this.x + this.radius > pLeft && this.x - this.radius < pRight && this.y + this.radius > pTop && this.y - this.radius < pBottom) { if (Math.abs(this.speedY) > 0.05) { this.speedY *= -0.3; this.y += this.speedY * 2.5; this.stuckTimer = Math.floor(10 + Math.random() * 20 / gameSpeedFactor); } this.platformInfluenceX += (this.x < p.x + p.width / 2 ? -0.1 : 0.1) * gameSpeedFactor; break; } } } if (this.stuckTimer > 0) { this.stuckTimer--; this.speedY = this.baseSpeedY * 0.05; } else { this.speedY = Math.min(this.speedY, this.baseSpeedY); } } draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } }
        class PowerUp{ constructor(x,y,type){ this.x=x;this.y=y;this.type=type;this.radius=14;this.collected=false;this.scale=1;this.symbol='';this.animationTimer=0;this.animationSpeed=0.06*gameSpeedFactor; switch(this.type){ case 'shield_bubble':this.color1='hsl(195, 45%, 70%)';this.color2='hsl(200, 50%, 60%)';this.symbol='SHD';break; case 'propulsion_boost':this.color1='hsl(120, 50%, 65%)';this.color2='hsl(140, 55%, 45%)';this.symbol='BST';break; case 'extra_life':this.color1='hsl(35, 70%, 60%)';this.color2='hsl(28, 75%, 45%)';this.symbol='+1UP';this.radius=16;break; case 'sonar_pulse':this.color1='hsl(280, 45%, 65%)';this.color2='hsl(270, 55%, 45%)';this.symbol='PULSE';break; } } draw(ctx){ if(this.collected)return; const offsetY=Math.sin(this.animationTimer)*6; drawCircleWithGradient(this.x,this.y+offsetY,this.radius,this.color1,this.color2,this.scale); ctx.fillStyle='black';ctx.strokeStyle='white';ctx.lineWidth=1.5; ctx.font = (this.type === 'extra_life') ? 'bold 10px Arial' : 'bold 11px Arial'; ctx.textAlign='center'; ctx.strokeText(this.symbol,this.x,this.y+offsetY+4);ctx.fillText(this.symbol,this.x,this.y+offsetY+4); } update(){this.animationTimer+=this.animationSpeed;}}
        class AbyssalJellyfish { constructor(x, y) { this.x = x; this.y = y; this.radius = 20 + Math.random() * 10; this.speedX = (Math.random() - 0.5) * 0.4 * gameSpeedFactor; this.speedY = (0.15 + Math.random() * 0.25) * gameSpeedFactor; this.colorLight = `hsla(${180 + Math.random()*60}, 70%, 70%, 0.4)`; this.colorDark = `hsla(${190 + Math.random()*60}, 60%, 50%, 0.6)`;  this.type = 'jellyfish'; this.bobOffset = Math.random() * Math.PI * 2; this.bobSpeed = 0.025 * gameSpeedFactor; this.tentacleCount = 6 + Math.floor(Math.random()*4); this.tentacleLengthBase = this.radius * 1.8; this.tentacleSegments = 4; this.pushedTimer = 0; this.pushForceX = 0; this.pushForceY = 0; this.tentaclePhases = []; for(let i=0; i<this.tentacleCount; i++) { this.tentaclePhases.push({ lenFactor: 0.8 + Math.random()*0.4, swayFactor: (Math.random()-0.5) * 20, curveFactor1: (Math.random()-0.5) * 10, curveFactor2: (Math.random()-0.5) * 10, }); } this.innerGlowHue = 180 + Math.random()*60; } update() { if (this.pushedTimer > 0) { this.x += this.pushForceX; this.y += this.pushForceY; this.pushForceX *= 0.92; this.pushForceY *= 0.92; this.pushedTimer--; } else { this.x += this.speedX; this.y += this.speedY; } this.bobOffset += this.bobSpeed; if (this.x + this.radius < -50 || this.x - this.radius > TARGET_CANVAS_WIDTH + 50 || this.y - this.radius > TARGET_CANVAS_HEIGHT + 100 || (this.y + this.radius < -100 && this.speedY <0)) { this.x = Math.random() * TARGET_CANVAS_WIDTH; this.y = (Math.random() < 0.5 ? -this.radius*2 - Math.random()*50 : TARGET_CANVAS_HEIGHT + this.radius*2 + Math.random()*50); this.speedY = (this.y < 0 ? 1 : -1) * (0.15 + Math.random() * 0.25) * gameSpeedFactor; this.speedX = (Math.random() - 0.5) * 0.4 * gameSpeedFactor; } if ((this.x - this.radius < 0 && (this.speedX < 0 || this.pushForceX < 0)) || (this.x + this.radius > TARGET_CANVAS_WIDTH && (this.speedX > 0 || this.pushForceX >0))) { this.speedX *= -0.8; this.pushForceX *= -0.5; this.x = Math.max(this.radius, Math.min(this.x, TARGET_CANVAS_WIDTH - this.radius)); } } draw(ctx) { const drawY = this.y + Math.sin(this.bobOffset * 1.5) * 4; const bellRadius = this.radius; const bellHeight = this.radius * 0.8; ctx.lineWidth = 2; for(let i=0; i < this.tentacleCount; i++) { ctx.beginPath(); let startX = this.x + Math.cos( (i / this.tentacleCount) * Math.PI*2 + this.bobOffset*0.3) * bellRadius * 0.6; let startY = drawY + bellHeight * 0.3 + Math.sin( (i / this.tentacleCount) * Math.PI*2 + this.bobOffset*0.3) * bellRadius * 0.1; ctx.moveTo(startX, startY); let prevX = startX; let prevY = startY; let tPhase = this.tentaclePhases[i]; let tLength = this.tentacleLengthBase * tPhase.lenFactor * (0.9 + Math.sin(this.bobOffset * 2 + i*0.7)*0.1); for (let j = 1; j <= this.tentacleSegments; j++) { let segmentRatio = j / this.tentacleSegments; let controlX = prevX + Math.sin(this.bobOffset * 0.8 + i + j*0.5) * tPhase.curveFactor1 * 0.5; let controlY = prevY + tLength / this.tentacleSegments * 0.5 + Math.cos(this.bobOffset + i + j*0.6) * tPhase.curveFactor2 * 0.5; let endX = startX + Math.sin(this.bobOffset * 0.5 + i * 0.8 + segmentRatio * Math.PI) * tPhase.swayFactor * segmentRatio; let endY = startY + tLength * segmentRatio + Math.cos(this.bobOffset * 1.1 + i*0.5 + segmentRatio * 0.7) * 5; ctx.quadraticCurveTo(controlX, controlY, endX, endY); prevX = endX; prevY = endY; } ctx.strokeStyle = `hsla(${200 + Math.sin(this.bobOffset + i*0.4)*30}, 60%, 70%, 0.5)`; ctx.stroke(); } ctx.beginPath(); ctx.ellipse(this.x, drawY, bellRadius, bellHeight, 0, Math.PI, Math.PI*2, false); ctx.ellipse(this.x, drawY, bellRadius * 0.95, bellHeight * 0.7, 0, 0, Math.PI, false); ctx.closePath(); const grad = ctx.createRadialGradient(this.x, drawY - bellHeight*0.2, bellRadius*0.1, this.x, drawY, bellRadius); grad.addColorStop(0, this.colorLight); grad.addColorStop(1, this.colorDark); ctx.fillStyle = grad; ctx.fill(); ctx.fillStyle = `hsla(${this.innerGlowHue + Math.sin(this.bobOffset*0.7)*10}, 80%, 85%, 0.3)`; ctx.beginPath(); ctx.ellipse(this.x, drawY - bellHeight * 0.1, bellRadius * 0.5, bellHeight * 0.4, 0, 0, Math.PI * 2); ctx.fill(); } }
        class StrongCurrent { constructor(y, height, strength) { this.x = 0; this.y = y; this.width = TARGET_CANVAS_WIDTH; this.height = height; this.strength = strength * gameSpeedFactor; this.particles = []; for (let i = 0; i < 30; i++) { this.particles.push({ x: Math.random() * this.width, y: this.y + Math.random() * this.height, size: Math.random() * 2 + 1, alpha: Math.random() * 0.3 + 0.1 }); } } update() { this.particles.forEach(p => { p.x += this.strength * 1.5; if (this.strength > 0 && p.x > this.width) p.x = 0; else if (this.strength < 0 && p.x < 0) p.x = this.width; }); } draw(ctx) { ctx.fillStyle = `rgba(100, 150, 255, 0.08)`; ctx.fillRect(this.x, this.y, this.width, this.height); this.particles.forEach(p => { ctx.fillStyle = `rgba(200, 220, 255, ${p.alpha})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); } }
        class SeaFloorKelp { constructor(x, maxHeight) { this.x = x; this.baseY = TARGET_CANVAS_HEIGHT; this.height = maxHeight * (0.4 + Math.random() * 0.6); this.width = 5 + Math.random() * 5; this.color = `rgba(60, 100, 60, ${0.3 + Math.random() * 0.25})`; this.phase = Math.random() * Math.PI * 2; this.swaySpeed = 0.01 + Math.random() * 0.01; this.segments = 3 + Math.floor(Math.random() * 3); } draw(ctx) { ctx.beginPath(); ctx.moveTo(this.x, this.baseY); let currentX = this.x; let currentY = this.baseY; const segmentHeight = this.height / this.segments; for (let i = 1; i <= this.segments; i++) { const sway = Math.sin(this.phase + frameCount * this.swaySpeed + i * 0.5) * (this.width * 0.5 * i); const nextX = this.x + sway; const nextY = this.baseY - segmentHeight * i; ctx.quadraticCurveTo(currentX + (sway - (currentX - this.x))/2 , currentY - segmentHeight/2 , nextX, nextY); currentX = nextX; currentY = nextY; } ctx.lineTo(currentX + Math.sin(this.phase + frameCount * this.swaySpeed + this.segments * 0.5 + 0.2) * this.width*0.2, currentY - 5); for (let i = this.segments; i >= 1; i--) { const sway = Math.sin(this.phase + frameCount * this.swaySpeed + i * 0.5) * (this.width * 0.5 * i); const prevY = this.baseY - segmentHeight * (i-1); const prevXBase = this.x + (i > 1 ? Math.sin(this.phase + frameCount * this.swaySpeed + (i-1) * 0.5) * (this.width * 0.5 * (i-1)) : 0); ctx.quadraticCurveTo(this.x + sway + this.width, this.baseY - segmentHeight * i + segmentHeight/2, prevXBase + this.width, prevY); } ctx.closePath(); ctx.fillStyle = this.color; ctx.fill(); } }
        function drawCircleWithGradient(x,y,r,c1,c2,s=1){ ctx.beginPath();const gr=ctx.createRadialGradient(x,y,0,x,y,r*s);gr.addColorStop(0,c1);gr.addColorStop(1,c2);ctx.fillStyle=gr;ctx.arc(x,y,r*s,0,Math.PI*2);ctx.fill();ctx.strokeStyle='rgba(0,0,0,0.4)';ctx.lineWidth=1.5;ctx.stroke();}
        
        function drawPlatform(platform){
            const {x,y,width,height, type, visualTheme, visualDetails, retractedPercent = 0} = platform;
            ctx.save();
            let effectiveW = width * (1 - retractedPercent * 0.5); 
            let effectiveH = height * (1 - retractedPercent);      
            let effectiveX = x + (width - effectiveW) / 2;

            if (effectiveH < 1 && type === 'retracting_coral') { ctx.restore(); return; } 

            let cornerRad = PLATFORM_CORNER_RADIUS; 
            let baseC1 = platform.color1, baseC2 = platform.color2;

            switch(visualTheme) {
                case 'rock_formation': baseC1 = baseC1 || 'hsl(210, 10%, 35%)'; baseC2 = baseC2 || 'hsl(210, 10%, 25%)'; break;
                case 'ancient_coral_shelf': baseC1 = baseC1 || 'hsl(10, 50%, 60%)'; baseC2 = baseC2 || 'hsl(5, 60%, 45%)'; cornerRad = PLATFORM_CORNER_RADIUS * 1.5; break;
                case 'dense_kelp_bed': baseC1 = 'hsl(125, 35%, 25%)'; baseC2 = 'hsl(125, 40%, 18%)'; break; 
                case 'sunken_driftwood': baseC1 = 'hsl(30, 20%, 35%)'; baseC2 = baseC2 || 'hsl(30, 20%, 22%)'; cornerRad = PLATFORM_CORNER_RADIUS * 0.5; break;
                case 'rusted_shipwreck_panel': baseC1 = baseC1 || 'hsl(200, 12%, 40%)'; baseC2 = baseC2 || 'hsl(200, 8%, 28%)'; cornerRad = 2; break;
                case 'industrial_grate': baseC1 = baseC1 || 'hsl(210, 7%, 30%)'; baseC2 = baseC2 || 'hsl(210, 8%, 18%)'; cornerRad = 2; break;
                default: baseC1 = baseC1 || 'hsl(210, 10%, 35%)'; baseC2 = baseC2 || 'hsl(210, 10%, 25%)';
            }
            drawPlatformCeiling_Base(effectiveX,y,effectiveW,effectiveH, baseC1, baseC2, cornerRad);

            if (visualDetails) {
                switch(visualTheme) {
                    case 'rock_formation': if (effectiveH > 5 && visualDetails.cracks) { ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1.5; visualDetails.cracks.forEach(crack => { if (retractedPercent < 0.8) { ctx.beginPath(); ctx.moveTo(effectiveX + crack.x1 * effectiveW, y + crack.y1 * effectiveH); ctx.lineTo(effectiveX + crack.x2 * effectiveW, y + crack.y2 * effectiveH); ctx.stroke(); } }); } break;
                    case 'ancient_coral_shelf': if (effectiveH > 3 && visualDetails.bumps) { visualDetails.bumps.forEach(bump => { ctx.fillStyle = bump.c; let r = bump.r * (1-retractedPercent*0.8); if (r > 1) { ctx.beginPath(); ctx.arc(effectiveX + bump.x * effectiveW, y + effectiveH - r * bump.yAnchor, r, 0, Math.PI*2); ctx.fill(); } }); } break;
                    case 'dense_kelp_bed': 
                        if (effectiveH > 10 && visualDetails.kelpStrands) { 
                            ctx.strokeStyle = `hsla(120, 30%, 30%, 0.6)`; 
                            ctx.lineWidth = Math.max(1, 3 * (1-retractedPercent*0.5));
                            
                            visualDetails.kelpStrands.forEach(strand => {
                                let kxBaseOnOriginal = x + strand.startXOffset * width; 
                                let kxAnimated = kxBaseOnOriginal + Math.sin(frameCount*0.05 + strand.phase) * 3;
                                if (kxAnimated < effectiveX - ctx.lineWidth || kxAnimated > effectiveX + effectiveW + ctx.lineWidth) return; 
                                let kelpLength = strand.baseLength * (1-retractedPercent*0.7);
                                if (kelpLength < 5) return;
                                ctx.beginPath(); ctx.moveTo(kxAnimated, y + effectiveH); 
                                let cp1x = kxAnimated + Math.sin(frameCount * 0.02 + strand.phase * 1.2) * 1;
                                let cp1y = y + effectiveH + kelpLength * 0.2;
                                let cp2x = kxAnimated + Math.cos(frameCount * 0.025 + strand.phase * 1.5) * 3;
                                let cp2y = y + effectiveH + kelpLength * 0.6;
                                let endX = kxAnimated + Math.sin(frameCount * 0.03 + strand.phase * 2) * 4;
                                let endY = y + effectiveH + kelpLength;
                                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY); ctx.stroke();
                            });
                        }
                        break;
                    case 'sunken_driftwood': if (effectiveH > 5 && effectiveW > 10 && visualDetails.grains) { ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1; visualDetails.grains.forEach(grain => { ctx.beginPath(); ctx.moveTo(effectiveX, y + grain.startY * effectiveH); ctx.bezierCurveTo(effectiveX+effectiveW*0.3, y + grain.startY * effectiveH + grain.c1y, effectiveX+effectiveW*0.7, y + grain.startY * effectiveH + grain.c2y, effectiveX+effectiveW, y + grain.startY * effectiveH); ctx.stroke(); }); } break;
                    case 'rusted_shipwreck_panel': if (effectiveH > 8 && effectiveW > 20 && visualDetails.rivets) { ctx.fillStyle = 'rgba(0,0,0,0.35)'; visualDetails.rivets.forEach(rivet => { let rivetSize = rivet.s * (1-retractedPercent*0.7); if (rivetSize < 0.5) return; ctx.beginPath(); ctx.arc(effectiveX + rivet.x * effectiveW, y + rivet.y * effectiveH, rivetSize,0,Math.PI*2); ctx.fill(); }); } break;
                    case 'industrial_grate': if (effectiveH > 5 && visualDetails.teeth) { ctx.fillStyle = baseC2; visualDetails.teeth.forEach(tooth => { let currentToothWidth = tooth.w * (1 - retractedPercent * 0.5); let currentToothHeight = tooth.h * (1 - retractedPercent * 0.3); if (currentToothWidth < 2 || currentToothHeight < 2) return; let toothX = effectiveX + tooth.normX * effectiveW - currentToothWidth/2; if (toothX + currentToothWidth > effectiveX + effectiveW) currentToothWidth = (effectiveX + effectiveW) - toothX; if (toothX < effectiveX) {currentToothWidth -= (effectiveX - toothX); toothX = effectiveX;} if (currentToothWidth > 1) { ctx.fillRect(toothX, y + effectiveH, currentToothWidth, currentToothHeight); } }); } break;
                }
            }

            if (effectiveH > 5) {  if (type === 'bouncy_vent') { ctx.fillStyle = 'rgba(160, 210, 190, 0.5)'; let ventY = y + effectiveH * 0.5; let ventSize = Math.min(effectiveW, effectiveH) * 0.4 * (1-retractedPercent*0.5); if (ventSize > 1) { ctx.beginPath(); ctx.ellipse(effectiveX + effectiveW/2, ventY, ventSize, ventSize*0.6, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(210,240,225,0.65)'; ctx.beginPath(); ctx.ellipse(effectiveX+effectiveW/2, ventY, ventSize*0.5, ventSize*0.3,0,0,Math.PI*2);ctx.fill(); } } else if (type === 'conveyor_current' && effectiveW > 20) { ctx.fillStyle = 'rgba(190, 170, 60, 0.6)'; let arrowSize = 10 * (1-retractedPercent*0.6); if (arrowSize > 2) { for (let i=0; i < effectiveW/30; i++) { ctx.beginPath(); let ax = effectiveX + 15 + i*30; if(ax > effectiveX + effectiveW - arrowSize - 5) continue; if (platform.direction > 0) { ctx.moveTo(ax - arrowSize, y + effectiveH/2 - arrowSize/2); ctx.lineTo(ax, y + effectiveH/2); ctx.lineTo(ax - arrowSize, y + effectiveH/2 + arrowSize/2); } else { ctx.moveTo(ax + arrowSize, y + effectiveH/2 - arrowSize/2); ctx.lineTo(ax, y + effectiveH/2); ctx.lineTo(ax + arrowSize, y + effectiveH/2 + arrowSize/2); } ctx.fill(); } } } 
                if (platform.hasLurker) { 
                    const lurkerBaseSize = 15; let currentLurkerSize = lurkerBaseSize * (1 - retractedPercent * 0.8); 
                    if (currentLurkerSize > 2) { 
                        const lx = effectiveX + effectiveW / 2; 
                        const ly = y + effectiveH - currentLurkerSize / 2; 
                        if(platform.lurkerState === 'firing') {
                            ctx.fillStyle = '#303033'; 
                            ctx.beginPath(); ctx.arc(lx, ly + currentLurkerSize*0.2, currentLurkerSize * 1.2, Math.PI*0.1, Math.PI*0.9); ctx.closePath(); ctx.fill();
                        } else {
                            ctx.fillStyle = platform.lurkerState === 'warning' ? '#383838' : '#1a1a1a'; 
                            ctx.beginPath(); ctx.arc(lx, ly + currentLurkerSize*0.2, currentLurkerSize, Math.PI*0.2, Math.PI*0.8); ctx.closePath(); ctx.fill();
                        }
                        ctx.fillStyle = '#A0A0A0'; 
                        ctx.beginPath(); ctx.arc(lx - currentLurkerSize*0.3, ly - currentLurkerSize*0.1, currentLurkerSize*0.2, 0, Math.PI*2); ctx.arc(lx + currentLurkerSize*0.3, ly - currentLurkerSize*0.1, currentLurkerSize*0.2, 0, Math.PI*2); ctx.fill(); 
                        if (platform.lurkerState === 'warning' || platform.lurkerState === 'firing') { 
                            ctx.fillStyle = platform.lurkerState === 'firing' ? 'rgba(40,40,45,0.5)' : 'rgba(50, 50, 55, 0.4)'; 
                            ctx.beginPath(); ctx.arc(lx, ly, currentLurkerSize * (1.2 + Math.sin(frameCount * (platform.lurkerState === 'firing' ? 0.35 : 0.25) ) * 0.3), 0, Math.PI*2); ctx.fill(); 
                        } 
                    } 
                } 
            }
            ctx.restore();
        }
        function drawPlatformCeiling_Base(x,y,w,h,c1,c2,cornerRadius){ if (w < 1 || h < 1) return; ctx.beginPath(); const grad=ctx.createRadialGradient(x+w/2,y+h/2,0,x+w/2,y+h/2,Math.max(w,h)*0.7); grad.addColorStop(0,c1);grad.addColorStop(1,c2);ctx.fillStyle=grad; if(typeof ctx.roundRect==='function'){ctx.roundRect(x,y,w,h,[cornerRadius]);ctx.fill();ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=2;ctx.stroke();} else{ctx.fillRect(x,y,w,h);ctx.strokeRect(x,y,w,h);} }
        function generatePlatformVisualDetails(platform) {
            platform.visualDetails = {};
            const { width, height, visualTheme } = platform;
            let c1 = platform.color1, c2 = platform.color2;

            switch(visualTheme) {
                case 'rock_formation': platform.visualDetails.cracks = []; for(let i=0; i < 2 + width/60; i++){ platform.visualDetails.cracks.push({ x1: Math.random(), y1: Math.random(), x2: Math.random(), y2: Math.random() }); } break;
                case 'ancient_coral_shelf': c1 = c1 || 'hsl(10, 50%, 60%)'; c2 = c2 || 'hsl(5, 60%, 45%)'; platform.visualDetails.bumps = []; for(let i=0; i < 3 + width/40; i++){ platform.visualDetails.bumps.push({ c: Math.random() < 0.5 ? c1 : c2, r: (2 + Math.random()*4), x: Math.random(), yAnchor: 0.1 + Math.random() * 0.8 }); } break;
                case 'dense_kelp_bed': 
                    platform.visualDetails.kelpStrands = [];
                    const kelpMarginPercent = 0.15; 
                    const kelpMarginPixels = width * kelpMarginPercent;
                    const kelpSpacing = 10; 
                    const availableWidthForKelp = width - 2 * kelpMarginPixels;
                    
                    if (availableWidthForKelp > 0) { 
                        const numKelp = Math.max(1, Math.floor(availableWidthForKelp / kelpSpacing) +1); 
                        for (let i = 0; i < numKelp; i++) { 
                            let offsetRatio = (numKelp > 1 ? (i / (numKelp -1)) : 0.5) ; // Center if only one
                            let actualOffsetInAvailable = offsetRatio * availableWidthForKelp;
                            let finalXOffsetOnPlatform = kelpMarginPixels + actualOffsetInAvailable;

                            platform.visualDetails.kelpStrands.push({ 
                                startXOffset: finalXOffsetOnPlatform / width, 
                                phase: i * (Math.PI / (numKelp > 1 ? (numKelp -1) : 1) ), // Spread phase for varied animation
                                baseLength: 25 + Math.random()*15 
                            }); 
                        }
                    }
                    break;
                case 'sunken_driftwood': platform.visualDetails.grains = []; for(let i=0; i < height/4; i++){ platform.visualDetails.grains.push({ startY: (i*4+2)/height, c1y: (Math.random()-0.5)*4, c2y: (Math.random()-0.5)*4 }); } break;
                case 'rusted_shipwreck_panel': platform.visualDetails.rivets = []; for(let i=0; i < width/25; i++){ platform.visualDetails.rivets.push({ x: (5+i*25)/width, y: (height-5)/height, s:2 }); platform.visualDetails.rivets.push({ x: (5+i*25)/width, y: 5/height, s:2 }); } break;
                case 'industrial_grate': platform.visualDetails.teeth = []; let toothWidth = 10; let toothHeight = 6; let numTeeth = Math.floor(width / (toothWidth + 4)); if (numTeeth > 0) { let totalTeethWidth = numTeeth * (toothWidth + 4) - 4; let startOffset = (width - totalTeethWidth) / 2; for (let i = 0; i < numTeeth; i++) { platform.visualDetails.teeth.push({ normX: (startOffset + i * (toothWidth + 4) + toothWidth/2) / width, w: toothWidth, h: toothHeight }); } } break;
            }
        }

        function drawGem(x,y,r,s=1){ drawCircleWithGradient(x,y,r,'rgba(100,220,255,0.95)','rgba(50,150,200,0.75)',s);ctx.fillStyle='rgba(220,255,255,0.85)';ctx.beginPath();ctx.arc(x-r*0.3*s,y-r*0.3*s,r*0.25*s,0,Math.PI*2);ctx.fill();}
        function drawAnglerFish(enemy){ const {x,y,size,angle} = enemy; let c1 = 'hsl(30, 60%, 40%)'; let c2 = 'hsl(25, 65%, 30%)'; ctx.save(); ctx.translate(x, y); ctx.rotate(angle); drawCircleWithGradient(0,0,size,c1,c2); ctx.fillStyle=c2; for(let i=0;i<8;i++){ const ang=(i/8)*Math.PI*2; ctx.beginPath(); ctx.moveTo(Math.cos(ang)*size*0.8, Math.sin(ang)*size*0.8); ctx.lineTo(Math.cos(ang+0.1)*size*1.25, Math.sin(ang+0.1)*size*1.25); ctx.lineTo(Math.cos(ang-0.1)*size*1.25, Math.sin(ang-0.1)*size*1.25); ctx.closePath();ctx.fill(); } ctx.fillStyle='white';ctx.beginPath();ctx.arc(size*0.3,-size*0.2,size*0.25,0,Math.PI*2);ctx.fill(); ctx.fillStyle='black';ctx.beginPath();ctx.arc(size*0.35,-size*0.2,size*0.12,0,Math.PI*2);ctx.fill(); const lureOffsetX = size * 0.7; const lureOffsetY = -size * 0.7; ctx.strokeStyle = 'rgba(180,180,130,0.8)'; ctx.lineWidth = size*0.1; ctx.beginPath(); ctx.moveTo(size*0.4, -size*0.3); ctx.lineTo(lureOffsetX, lureOffsetY); ctx.stroke(); ctx.fillStyle='hsl(50, 70%, 55%)';ctx.beginPath();ctx.arc(lureOffsetX,lureOffsetY,size*0.15,0,Math.PI*2);ctx.fill(); ctx.restore(); }
        function generateBackgroundColors(){ let hTop,sTop,lTop,hMid,sMid,lMid,hBot,sBot,lBot; const L=(internalLevel-1); const brightnessTier=Math.floor(L/3); const hueCycleInTier=L%3; const isDarkZone = (internalLevel > 2 && internalLevel % 4 === 0 && internalLevel > 0); let baseLightnessDarkest= isDarkZone ? 2 : (5+brightnessTier*7); baseLightnessDarkest=Math.min(baseLightnessDarkest,45); let gradientSpan=Math.max(10,30-brightnessTier*3); if (isDarkZone) gradientSpan = Math.max(5, 15 - brightnessTier * 2); let currentSaturation=Math.max(20,70-(currentDepth/STARTING_DEPTH)*60-brightnessTier*3); if (isDarkZone) currentSaturation = Math.max(10, 30 - (currentDepth/STARTING_DEPTH)*25 - brightnessTier*2); if(internalLevel===1 && !isDarkZone){ gradientBaseHue=220; hBot=gradientBaseHue;sBot=0;lBot=0; hTop=(hBot+10)%360; sTop=Math.max(10,currentSaturation-15); lTop=Math.min(20,lBot+gradientSpan); } else { let prevDarkestHue=gradientBaseHue; hBot=(prevDarkestHue+Math.random()*30-15+360)%360; sBot=currentSaturation; lBot=baseLightnessDarkest; hTop=(hBot+10+Math.random()*10+360)%360; sTop=Math.max(10,currentSaturation-10); lTop=Math.min(isDarkZone ? 30 : 80,lBot+gradientSpan); gradientBaseHue=hBot; } if(hueCycleInTier===1){ hTop=(hTop+120)%360; hBot=(hBot+120)%360; } else if(hueCycleInTier===2){ hTop=(hTop+240)%360; hBot=(hBot+240)%360; } hMid=(hTop+hBot)/2; if(Math.abs(hTop-hBot)>180)hMid=(hMid+180)%360; sMid=(sTop+sBot)/2; lMid=(lTop+lBot)/2; currentGradientColors=[`hsl(${hTop},${sTop}%,${lTop}%)`,`hsl(${hMid},${sMid}%,${lMid}%)`,`hsl(${hBot},${sBot}%,${lBot}%)`]; }
        function setupLevelBackgroundEffects() { ambientBubbles = []; foregroundBubbles = []; const numAmbientBubbles = 35 + Math.floor(internalLevel * 2.5); for (let i = 0; i < numAmbientBubbles; i++) { ambientBubbles.push(new AmbientBubble(Math.random() < 0.7, 'ambient')); } const numFgBubbles = 7 + Math.floor(internalLevel * 0.3); for (let i = 0; i < numFgBubbles; i++) { foregroundBubbles.push(new AmbientBubble(true, 'foreground')); } }
        function checkAllOrbsCollected(){ if(stars.every(s=>s.collected)){if(!exitPlatform&&stars.length>0){exitPlatform={x:TARGET_CANVAS_WIDTH/2-60,y:EXIT_CEILING_UNDERSIDE_Y-EXIT_CEILING_HEIGHT,width:120,height:EXIT_CEILING_HEIGHT,visualTheme: 'rock_formation', color1:'hsl(210, 10%, 40%)',color2:'hsl(210, 10%, 30%)',static:true,type:'exit_portal_ceiling',active:true}; generatePlatformVisualDetails(exitPlatform);}}}
        function initLevel(isFullReset = false) { platforms=[];enemies=[];stars=[];powerUps=[];gameEffectParticles=[];exitPlatform=null;seaFloorDecorations=[]; strongCurrents = []; seaFloorKelps = []; if(isFullReset){ internalLevel=1;currentDepth=STARTING_DEPTH;airCollected=0;player.lives=3;gradientBaseHue=200; player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL; platformBaseSpeed = 0.42 * gameSpeedFactor; } generateBackgroundColors();setupLevelBackgroundEffects(); const startCeilingH=20;const startCeilingTopY=TARGET_CANVAS_HEIGHT-150; platforms.push({x:TARGET_CANVAS_WIDTH/2-70,y:startCeilingTopY,width:140,height:startCeilingH,visualTheme: 'rock_formation', color1:'hsl(210, 10%, 35%)',color2:'hsl(210, 10%, 25%)',static:false,type:'start_ceiling',active:true,direction:1,speed:platformBaseSpeed*0.6}); generatePlatformVisualDetails(platforms[0]); player.x=platforms[0].x+platforms[0].width/2;player.y=platforms[0].y+platforms[0].height+player.radius+40;player.vx=0;player.vy=0;player.isAttached=false;player.attachedPlatform=null;player.canTakeDamage=true;clearTimeout(player.damageCooldownTimeout);player.invincible=false;player.invincibleTimer=0;player.speedBoost=false;player.speedBoostTimer=0; player.sonarPulseActive=false; player.sonarPulseTimer=0; player.inkedTimer = 0; let currentCeilingUndersideY=platforms[0].y+platforms[0].height; const highestPossibleCeilingTopY=TOP_SURFACE_DEATH_Y+player.radius+EXIT_CEILING_HEIGHT+20; let numDynamicCeilings=3+Math.floor(internalLevel*1.1); const availableVSpace=currentCeilingUndersideY-highestPossibleCeilingTopY; let dynamicMaxFloat = (player.currentPushForce * player.currentPushForce) / (2*Math.abs(BUOYANCY)); dynamicMaxFloat = Math.max(dynamicMaxFloat, player.radius * 3 + 20); let minGapForGen = dynamicMaxFloat * MIN_CEILING_UNDERSIDE_GAP_FACTOR; if(availableVSpace > 0){ numDynamicCeilings = Math.min(numDynamicCeilings, Math.floor(availableVSpace / (minGapForGen + startCeilingH))); } else { numDynamicCeilings = 0; } numDynamicCeilings = Math.max(numDynamicCeilings, internalLevel === 1 ? 1 : 2); let dynamicCeilingCfgs = []; let specialCeilingsToGen = []; let specialPlatformBudget = 0; if (internalLevel >= 2) specialPlatformBudget = 1; if (internalLevel >= 3) specialPlatformBudget = 1 + Math.floor((internalLevel-3)/2.2); for(let k = 0; k < specialPlatformBudget; k++) { let availableSpecials = SPECIAL_PLATFORM_TYPES.slice(); if (internalLevel < 3) { availableSpecials = availableSpecials.filter(type => type === 'disappearing_coral' || type === 'bouncy_vent' || type === 'conveyor_current'); } else if (internalLevel < 4) { availableSpecials = availableSpecials.filter(type => type !== 'slippery_kelp_patch'); } if (availableSpecials.length > 0) { specialCeilingsToGen.push(availableSpecials[Math.floor(Math.random() * availableSpecials.length)]); } } for(let i = 0; i < numDynamicCeilings; i++){ let platW = 180 - internalLevel * 7; platW = Math.max(70, platW) + Math.random() * (internalLevel < 5 ? 35 : 10); const platH = 20; let platX = Math.random() * (TARGET_CANVAS_WIDTH - platW); dynamicMaxFloat = (player.currentPushForce * player.currentPushForce) / (2*Math.abs(BUOYANCY)); dynamicMaxFloat = Math.max(dynamicMaxFloat, player.radius * 3 + 20); let currentMinGap = dynamicMaxFloat * MIN_CEILING_UNDERSIDE_GAP_FACTOR; let currentMaxGap = dynamicMaxFloat * MAX_CEILING_UNDERSIDE_GAP_FACTOR; let newCeilingUndersideY_max = currentCeilingUndersideY - currentMinGap; let newCeilingUndersideY_min = currentCeilingUndersideY - currentMaxGap; newCeilingUndersideY_min = Math.max(newCeilingUndersideY_min, highestPossibleCeilingTopY + platH); if(newCeilingUndersideY_min >= newCeilingUndersideY_max - platH / 1.5){ if (i < (internalLevel === 1 ? 1 : 2)) { newCeilingUndersideY_min = newCeilingUndersideY_max - platH / 1.5 -1; } else break; } let y_under = Math.random() * (newCeilingUndersideY_max - newCeilingUndersideY_min) + newCeilingUndersideY_min; let y_top = y_under - platH; let currentType='normal_ceiling'; let platSpd = platformBaseSpeed * (0.4 + internalLevel*0.07 + Math.random()*0.45); platSpd = Math.min(platSpd, platformBaseSpeed * 3.5); platSpd = Math.max(platSpd, platformBaseSpeed * 0.3); let platDir=(Math.random()<0.5?1:-1);let isStat=false; let visual = PLATFORM_VISUAL_THEMES[Math.floor(Math.random() * PLATFORM_VISUAL_THEMES.length)]; let platformData={x:platX,y:y_top,width:platW,height:platH,visualTheme: visual, color1:null,color2:null,static:isStat,type:currentType,active:true,direction:platDir,speed:platSpd,originalColor1:null,timer:Math.floor(80/gameSpeedFactor),reappearTime: Math.floor(180/gameSpeedFactor), hasLurker: false, lurkerChargeTime: 0, lurkerState: 'idle', lurkerMaxCharge: Math.floor(120 / gameSpeedFactor), lurkerFireTime: Math.floor(30 / gameSpeedFactor), lurkerFireTimer: 0, lurkerCooldownTime: Math.floor(180 / gameSpeedFactor), lurkerCooldownTimer: 0, lurkerInkCloudRadius: 0, lurkerMaxInkCloudRadius: 60, isRetracted: false, retractTimer: 0, maxRetractTime: Math.floor(180/gameSpeedFactor), retractedPercent: 0 }; let willHaveEnemy = (enemies.filter(e => e.type !== 'jellyfish').length < Math.floor(internalLevel/1.8)+ (internalLevel > 2 ? 1:0) && Math.random() < 0.05 + internalLevel*0.08 && i > 0 && internalLevel > 1); if(willHaveEnemy && internalLevel<8) platformData.width = Math.max(platformData.width, 150); if(specialCeilingsToGen.length>0&&Math.random()<(0.18 + internalLevel*0.075)){ platformData.type=specialCeilingsToGen.shift(); switch(platformData.type){ case 'disappearing_coral': platformData.visualTheme = 'ancient_coral_shelf'; platformData.color1='hsl(10, 50%, 60%)';platformData.color2='hsl(5, 60%, 45%)';platformData.static=true; platformData.reappearTime = Math.floor(360 / gameSpeedFactor); break; case 'bouncy_vent': platformData.visualTheme = 'rock_formation'; platformData.color1='hsl(160, 50%, 75%)';platformData.color2='hsl(170, 70%, 45%)';platformData.static=true;platformData.speed=0;break; case 'conveyor_current': platformData.visualTheme = 'rusted_shipwreck_panel'; platformData.color1='hsl(50, 50%, 55%)';platformData.color2='hsl(45, 60%, 40%)';platformData.static=false;platformData.speed*=1.3;break; case 'retracting_coral': platformData.visualTheme = 'ancient_coral_shelf'; platformData.color1='hsl(0, 40%, 60%)'; platformData.color2='hsl(0, 50%, 45%)'; platformData.static=true; platformData.maxRetractTime = Math.floor((150 + Math.random()*60)/gameSpeedFactor); break; case 'slippery_kelp_patch': platformData.visualTheme = 'dense_kelp_bed'; platformData.static = Math.random() < 0.5; break; } } if (platformData.type === 'slippery_kelp_patch') platformData.visualTheme = 'dense_kelp_bed'; if (internalLevel >= 5 && platformData.type !== 'bouncy_vent' && platformData.type !== 'disappearing_coral' && platformData.type !== 'retracting_coral' && platformData.visualTheme !== 'industrial_grate' && platformData.width > 100 && Math.random() < 0.1 + (internalLevel - 5) * 0.03) { platformData.hasLurker = true; willHaveEnemy = false; } generatePlatformVisualDetails(platformData); dynamicCeilingCfgs.push(platformData); if(willHaveEnemy && platformData.type !=='disappearing_coral' && platformData.type !=='bouncy_vent' && !platformData.hasLurker){ enemies.push({x:platformData.x+platformData.width/2,y:platformData.y+platformData.height+20,size:16,platformAttached:platformData,direction:Math.random()>0.5?1:-1,speed:platformBaseSpeed*(0.3+internalLevel*0.04+Math.random()*0.3),color1:'hsl(30, 60%, 40%)',color2:'hsl(25, 65%, 30%)', type:'angler', angle: Math.random() * Math.PI * 2 }); } currentCeilingUndersideY=y_under; } dynamicCeilingCfgs.sort((a,b)=>b.y-a.y);platforms.splice(1,0,...dynamicCeilingCfgs); if(internalLevel===1){ platforms.push({x:0,y:TARGET_CANVAS_HEIGHT-BOTTOM_DEATH_FLOOR_HEIGHT,width:TARGET_CANVAS_WIDTH,height:BOTTOM_DEATH_FLOOR_HEIGHT,visualTheme:'rock_formation', color1:'#3E2723',color2:'#201512',static:true,deadly:true,type:'ocean_floor',active:true}); generatePlatformVisualDetails(platforms[platforms.length-1]); const kelpDensity = 15; const numGroundKelp = Math.floor(TARGET_CANVAS_WIDTH / kelpDensity) +1; for(let i=0; i < numGroundKelp; i++) { seaFloorKelps.push(new SeaFloorKelp(i * kelpDensity, 40 + Math.random() * 80)); } } else { seaFloorKelps = []; } stars=[]; const gemR=11;const numGems=Math.max(2,Math.floor(platforms.filter(p=>p.type!=='start_ceiling'&&p.type!=='ocean_floor').length/1.8)+Math.floor(internalLevel/1.2));for(let i=0;i<numGems;i++){let v=false;let gX,gY;let att=0;while(!v&&att<50){att++;const cPs=platforms.filter(p=>p.type!=='start_ceiling'&&p.type!=='ocean_floor'&&!p.deadly && p.active);if(cPs.length===0)break;const bC=cPs[Math.floor(Math.random()*cPs.length)];gX=bC.x+Math.random()*bC.width;gY=bC.y+bC.height+gemR+(15+Math.random()*35);const floorBoundary=(internalLevel===1?(TARGET_CANVAS_HEIGHT-BOTTOM_DEATH_FLOOR_HEIGHT):TARGET_CANVAS_HEIGHT);gY=Math.min(gY,floorBoundary-gemR-10);v=true;for(const pl of platforms){if(gX+gemR>pl.x&&gX-gemR<pl.x+pl.width&&gY+gemR>pl.y&&gY-gemR<pl.y+pl.height){v=false;break;}}if(!v)continue;for(const oG of stars){const dx=gX-oG.x;const dy=gY-oG.y;if(Math.sqrt(dx*dx+dy*dy)<gemR*3.5){v=false;break;}}}if(v){stars.push({x:gX,y:gY,radius:gemR,scale:1,collected:false,bobOffset:Math.random()*Math.PI*2,bobSpeed:0.025+Math.random()*0.02});}} if (internalLevel >= 2) { let powerUpChance = 0.20 + (internalLevel-2) * 0.05; if (Math.random() < powerUpChance) { let puX, puY, validPosition = false, attempts = 0; const puRadius = 14; while(!validPosition && attempts < 20) { attempts++; const platformCandidates = platforms.filter(p => p.type !== 'start_ceiling' && p.type !== 'ocean_floor' && !p.deadly && p.active); if (platformCandidates.length > 0) { const basePlatform = platformCandidates[Math.floor(Math.random() * platformCandidates.length)]; puX = basePlatform.x + Math.random() * basePlatform.width; puY = basePlatform.y + basePlatform.height + puRadius + (15 + Math.random() * 20); const floorBoundary = (internalLevel === 1 ? (TARGET_CANVAS_HEIGHT - BOTTOM_DEATH_FLOOR_HEIGHT) : TARGET_CANVAS_HEIGHT); puY = Math.min(puY, floorBoundary - puRadius - 10); validPosition = true; for (const pl of platforms) { if (puX + puRadius > pl.x && puX - puRadius < pl.x + pl.width && puY + puRadius > pl.y && puY - puRadius < pl.y + pl.height) { validPosition = false; break; } } if (validPosition) { for (const s of stars) { const dx = puX - s.x; const dy = puY - (s.y + Math.sin(s.bobOffset+frameCount*s.bobSpeed)*3); if (Math.sqrt(dx * dx + dy * dy) < puRadius + s.radius + 15) { validPosition = false; break; } } } if (validPosition) { for (const oPu of powerUps) { const dx = puX - oPu.x; const dy = puY - (oPu.y + Math.sin(oPu.animationTimer)*6); if (Math.sqrt(dx * dx + dy * dy) < puRadius * 3) { validPosition = false; break; } } } } else { break; }  } if (validPosition) { let puTypeRand = Math.random(); let puType; if (internalLevel >= 6 && puTypeRand < 0.25) puType = 'extra_life'; else if (internalLevel >= 4 && puTypeRand < 0.5) puType = 'sonar_pulse'; else if (puTypeRand < 0.75) puType = 'shield_bubble'; else puType = 'propulsion_boost'; powerUps.push(new PowerUp(puX, puY, puType)); } } } if (internalLevel >= 3) { const numJellies = Math.floor((internalLevel - 2) / 2) + (Math.random() < 0.3 ? 1 : 0); for (let i = 0; i < numJellies; i++) { enemies.push(new AbyssalJellyfish(Math.random() * TARGET_CANVAS_WIDTH, Math.random() * TARGET_CANVAS_HEIGHT * 0.8)); } } if (internalLevel >= 4 && Math.random() < 0.35 + (internalLevel - 4) * 0.06) { const currentY = Math.random() * (TARGET_CANVAS_HEIGHT * 0.6) + TARGET_CANVAS_HEIGHT * 0.1; const currentHeight = 80 + Math.random() * 70; const currentStrength = (Math.random() < 0.5 ? 1 : -1) * (0.45 + Math.random() * 0.45 + internalLevel * 0.04); strongCurrents.push(new StrongCurrent(currentY, currentHeight, currentStrength)); } checkAllOrbsCollected(); }
        function update(){ if(justRestartedFromGameOver && !keys[' ']){ justRestartedFromGameOver = false; } switch(gameState){ case 'start': if(keys[' ']){ playerCanMove=true; gameState='playing'; keys[' ']=false; updateUIVisibility(); attemptPlayMusic(); } break; case 'playing': if(keys['p']||keys['Escape']){ gameState='paused'; keys['p']=false; keys['Escape']=false; if(abyssalDroneMusic) abyssalDroneMusic.pause(); if(cyclingPlatformsMusic) cyclingPlatformsMusic.pause(); playerCanMove=false; updateUIVisibility(); } updatePlayer(); updatePlatforms(); updateEnemies(); updateStars(); updatePowerUps(); updateGameEffectParticles(); updateAmbientBubbles(); checkExitPlatform(); strongCurrents.forEach(c => c.update()); break; case 'paused': break; case 'transitioning': transitionAlpha+=transitionSpeed; if(transitionAlpha>=1){ transitionAlpha=1; if(transitionCallback) transitionCallback(); transitionSpeed*=-1; } else if(transitionAlpha<=0){ transitionAlpha=0; transitionSpeed=Math.abs(transitionSpeed); gameState=(transitionCallback&&typeof transitionCallback.toString==='function'&&transitionCallback.toString().includes("gameState='gameOver'"))?'gameOver':(transitionCallback&&typeof transitionCallback.toString==='function'&&transitionCallback.toString().includes("gameState='gameWon'"))?'gameWon':'playing'; playerCanMove = gameState === 'playing'; updateUIVisibility(); } break; case 'gameOver': if ((keys[' '] || keys['p'] || keys['Escape']) && !justRestartedFromGameOver) { attemptPlayMusic(); resetGame(true); if (keys[' ']) keys[' '] = false; if (keys['p']) keys['p'] = false; if (keys['Escape']) keys['Escape'] = false; justRestartedFromGameOver = true; } break; case 'gameWon': if ((keys[' '] || keys['p'] || keys['Escape']) && !justRestartedFromGameOver) { attemptPlayMusic(); resetGame(true); if (keys[' ']) keys[' '] = false; if (keys['p']) keys['p'] = false; if (keys['Escape']) keys['Escape'] = false; justRestartedFromGameOver = true; } break; } }
        function updatePlayer() { if (!playerCanMove) { player.vx = 0; return; } if(player.inkedTimer > 0) player.inkedTimer--; player.currentPushForce = PLAYER_BASE_PUSH_INITIAL - (player.radius - player.baseRadius) * 0.30; player.currentPushForce = Math.max(player.currentPushForce, PLAYER_BASE_PUSH_INITIAL * 0.25); let currentSpeed = player.baseSpeed; if (player.speedBoost) { currentSpeed *= 1.7; player.speedBoostTimer--; if (player.speedBoostTimer <= 0) player.speedBoost = false; } let currentHorizontalResistance = WATER_RESISTANCE_H_NORMAL; if (player.isAttached && player.attachedPlatform && player.attachedPlatform.type === 'slippery_kelp_patch') { currentHorizontalResistance = WATER_RESISTANCE_H_SLIPPERY; } if (keys.ArrowLeft) player.vx = Math.max(player.vx - (0.3 * gameSpeedFactor), -currentSpeed); else if (keys.ArrowRight) player.vx = Math.min(player.vx + (0.3 * gameSpeedFactor), currentSpeed); else player.vx *= currentHorizontalResistance; player.x += player.vx; if (keys[' ']) { if (player.isAttached) { player.vy = player.currentPushForce; if (player.attachedPlatform.type === 'retracting_coral' && !player.attachedPlatform.isRetracted) { player.attachedPlatform.isRetracted = true; player.attachedPlatform.active = false; player.attachedPlatform.retractTimer = player.attachedPlatform.maxRetractTime; playRetractPlatformSound(); } player.isAttached = false; player.attachedPlatform = null; playPushFromCeilingSound(); } else { let canQuickPush = false; let quickPushTargetPlatform = null; for (const plat of platforms.concat(exitPlatform ? [exitPlatform] : [])) { if (!plat || !plat.active || plat.deadly || plat.type === 'ocean_floor') continue; const playerTop = player.y - player.radius; const platformUnderside = plat.y + plat.height; if (player.x + player.radius * 0.6 > plat.x && player.x - player.radius * 0.6 < plat.x + plat.width) { if (playerTop < platformUnderside + (5 * gameSpeedFactor) && playerTop > platformUnderside - (35 * gameSpeedFactor) && player.vy <= (0.5 * gameSpeedFactor)) { canQuickPush = true; quickPushTargetPlatform = plat; break; } } } if (canQuickPush) { player.vy = player.currentPushForce * 0.8; playPushFromCeilingSound(); if (quickPushTargetPlatform && quickPushTargetPlatform.type === 'conveyor_current') { player.vx -= quickPushTargetPlatform.direction * quickPushTargetPlatform.speed * 0.3; } if (quickPushTargetPlatform && quickPushTargetPlatform.type === 'retracting_coral' && !quickPushTargetPlatform.isRetracted) { quickPushTargetPlatform.isRetracted = true; quickPushTargetPlatform.active = false; quickPushTargetPlatform.retractTimer = quickPushTargetPlatform.maxRetractTime; playRetractPlatformSound(); } } for (const enemy of enemies) { if (enemy.type === 'jellyfish') { const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dist = Math.sqrt(dx*dx + dy*dy); const pushRadius = player.radius + 60; if (dist < pushRadius && dist > 0) { const pushStrength = 8 * gameSpeedFactor; enemy.pushForceX = (dx / dist) * pushStrength; enemy.pushForceY = (dy / dist) * pushStrength; enemy.pushedTimer = Math.floor(15 / gameSpeedFactor); enemy.speedX = 0; enemy.speedY = 0; playJellyfishPushedSound(); } } } } keys[' '] = false; } if (!player.isAttached) { player.vy += BUOYANCY; const PULL_UP_FORCE = PLATFORM_ATTACH_PULL_UP; const PULL_UP_RANGE = 30 * gameSpeedFactor; const JUST_PAST_OFFSET = 2 * gameSpeedFactor; const SNAP_TOLERANCE = 2.0 * gameSpeedFactor; for (const platform of platforms.concat(exitPlatform ? [exitPlatform] : [])) { if (!platform || !platform.active || platform.deadly || platform.type === 'ocean_floor') continue; const playerTopY = player.y - player.radius; const platformBottomY = platform.y + platform.height; const prevFrameVy = (player.vy - BUOYANCY) / WATER_RESISTANCE_V; const prevPlayerActualY = player.y - prevFrameVy ; const prevPlayerTopY = prevPlayerActualY - player.radius; if (player.x + player.radius * 0.8 > platform.x && player.x - player.radius * 0.8 < platform.x + platform.width) { if (player.vy <= 0.1 * gameSpeedFactor) { if (playerTopY > platformBottomY - PULL_UP_RANGE && playerTopY < platformBottomY + JUST_PAST_OFFSET) { player.vy += PULL_UP_FORCE; } if (playerTopY <= platformBottomY + JUST_PAST_OFFSET && prevPlayerTopY > platformBottomY - SNAP_TOLERANCE) { player.y = platformBottomY + player.radius; player.vy = 0; player.isAttached = true; player.attachedPlatform = platform; playAttachToCeilingSound(); if (platform.type === 'bouncy_vent') { player.vy = player.currentPushForce * 1.7; player.isAttached = false; player.attachedPlatform = null; playBouncyVentSound(); } else if (platform.type === 'exit_portal_ceiling') { checkExitPlatform(); } break; } } } } } player.vy *= WATER_RESISTANCE_V; player.y += player.vy; for (const current of strongCurrents) { if (player.y + player.radius > current.y && player.y - player.radius < current.y + current.height) { player.x += current.strength; } } if (player.x < player.radius) { player.x = player.radius; player.vx *= -0.3; } if (player.x > TARGET_CANVAS_WIDTH - player.radius) { player.x = TARGET_CANVAS_WIDTH - player.radius; player.vx *= -0.3; } if (player.y - player.radius < TOP_SURFACE_DEATH_Y && !player.invincible && player.canTakeDamage) { playerDie("surfaced_abyss"); } const deadlyFloor = platforms.find(p => p.type === 'ocean_floor'); if (internalLevel === 1 && deadlyFloor && player.y + player.radius > deadlyFloor.y) { player.y = deadlyFloor.y - player.radius; if (player.vy > 0) { player.vy = 0; } } else if (player.y + player.radius > TARGET_CANVAS_HEIGHT) { player.y = TARGET_CANVAS_HEIGHT - player.radius; if (player.vy > 0) { player.vy = 0;} } if (player.isAttached && player.attachedPlatform) { const p = player.attachedPlatform; if (!p.active) { player.isAttached = false; player.attachedPlatform = null; } else { let stillHorizontallyOn = (player.x + player.radius * 0.7 > p.x && player.x - player.radius * 0.7 < p.x + p.width); if (p.type === 'conveyor_current') { player.x += p.direction * p.speed * 1.7; if ((p.direction > 0 && player.x + player.radius * 0.3 >= p.x + p.width ) || (p.direction < 0 && player.x - player.radius * 0.3 <= p.x )) { player.isAttached = false; player.vx += p.direction * p.speed * 1.0; stillHorizontallyOn = false; } } else if (!p.static) { player.x += p.direction * p.speed; } if (player.isAttached && stillHorizontallyOn) { player.y = p.y + p.height + player.radius; } else if (player.isAttached) { player.isAttached = false; } if (p.hasLurker) { if (player.isAttached && player.attachedPlatform === p) { if (p.lurkerState === 'idle' || p.lurkerState === 'warning') { p.lurkerChargeTime++; if (p.lurkerState === 'idle' && p.lurkerChargeTime > p.lurkerMaxCharge * 0.5) { p.lurkerState = 'warning'; playLurkerWarningSound(); } if (p.lurkerState === 'warning' && p.lurkerChargeTime >= p.lurkerMaxCharge) { p.lurkerState = 'firing'; p.lurkerFireTimer = p.lurkerFireTime; p.lurkerInkCloudRadius = 0; playLurkerChargeSound(); } } } else { if (p.lurkerState === 'warning' || p.lurkerState === 'firing') { p.lurkerState = 'cooldown'; p.lurkerCooldownTimer = p.lurkerCooldownTime; p.lurkerChargeTime = 0; p.lurkerFireTimer = 0; p.lurkerInkCloudRadius = 0;} } } if (!player.isAttached) { player.attachedPlatform = null; } } } else { platforms.forEach(p => { if(p.hasLurker && (p.lurkerState === 'warning' || p.lurkerState === 'firing')) { p.lurkerState = 'cooldown'; p.lurkerCooldownTimer = p.lurkerCooldownTime / 2; p.lurkerChargeTime = 0; p.lurkerFireTimer = 0; p.lurkerInkCloudRadius = 0;} }); } if (player.invincibleTimer > 0) { player.invincibleTimer--; if (player.invincibleTimer <= 0) { player.invincible = false; player.canTakeDamage = true; clearTimeout(player.damageCooldownTimeout); } } if (player.sonarPulseActive) { player.sonarPulseTimer--; player.sonarPulseRadius += (player.sonarPulseMaxRadius / (Math.floor(180 / gameSpeedFactor) / 3)); if (player.sonarPulseTimer % Math.floor(60 / gameSpeedFactor) === 0 && player.sonarPulseCount > 0) { playSonarPulseFireSound(); enemies.forEach(enemy => { if (enemy.type === 'angler' || enemy.type === 'jellyfish') { const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist < player.sonarPulseRadius && dist > 0) { const pushForce = 5 * gameSpeedFactor; enemy.speedX = (dx / dist) * pushForce; enemy.speedY = (dy / dist) * pushForce; if(enemy.pushedBySonarTimer === undefined) enemy.pushedBySonarTimer = 0; enemy.pushedBySonarTimer = Math.floor(30 / gameSpeedFactor); } } }); player.sonarPulseCount--; } if (player.sonarPulseTimer <= 0 || player.sonarPulseCount <= 0) { player.sonarPulseActive = false; player.sonarPulseRadius = 0; } } for (let i = stars.length - 1; i >= 0; i--) { const gem = stars[i]; if (!gem.collected) { const dx = player.x - gem.x; const dy = player.y - (gem.y + Math.sin(gem.bobOffset + frameCount * gem.bobSpeed) * 3); if (Math.sqrt(dx * dx + dy * dy) < player.radius + gem.radius) { gem.collected = true; airCollected += 20; player.radius = Math.min(player.maxRadius, player.radius + player.radiusGrowthPerStar); playGemSound(); checkAllOrbsCollected(); } } } for (let i = powerUps.length - 1; i >= 0; i--) { const pu = powerUps[i]; if (!pu.collected) { const puDrawY = pu.y + Math.sin(pu.animationTimer) * 6; const dx = player.x - pu.x; const dy = player.y - puDrawY; if (Math.sqrt(dx * dx + dy * dy) < player.radius + pu.radius) { pu.collected = true; playPowerUpSound(pu.type); if (pu.type === 'shield_bubble') { player.invincible = true; player.invincibleTimer = Math.floor(300 / gameSpeedFactor); } else if (pu.type === 'propulsion_boost') { player.speedBoost = true; player.speedBoostTimer = Math.floor(300 / gameSpeedFactor); } else if (pu.type === 'extra_life') { player.lives++; } else if (pu.type === 'sonar_pulse') { player.sonarPulseActive = true; player.sonarPulseTimer = Math.floor(180 / gameSpeedFactor); player.sonarPulseRadius = player.radius + 10; player.sonarPulseCount = 3; } powerUps.splice(i, 1); } } } for (const enemy of enemies) { if (enemy.type === 'jellyfish') { const enemyDrawY = enemy.y + Math.sin(enemy.bobOffset * 1.5) * 4; const dx = player.x - enemy.x; const dy = player.y - enemyDrawY; const dist = Math.sqrt(dx*dx + dy*dy); if (dist < player.radius + enemy.radius * 0.8 && enemy.pushedTimer <=0) { if (!player.invincible && player.canTakeDamage) { playJellyfishBounceSound(); const bounceStrength = 7.0 * gameSpeedFactor; player.vx = (dx / dist) * bounceStrength * 0.8; player.vy = (dy / dist) * bounceStrength * 1.2; if(player.isAttached) { player.isAttached = false; player.attachedPlatform = null;} const jellyNudgeStrength = 2.0 * gameSpeedFactor; enemy.pushForceX = -(dx / dist) * jellyNudgeStrength; enemy.pushForceY = -(dy / dist) * jellyNudgeStrength; enemy.pushedTimer = Math.floor(12 / gameSpeedFactor); } } } else if (enemy.type === 'angler'){ const dx = player.x - enemy.x; const dy = player.y - enemy.y; if (Math.sqrt(dx * dx + dy * dy) < player.radius + enemy.size * 0.7 && !player.invincible && player.canTakeDamage) { playerDie("hit_enemy"); player.vy = (BUOYANCY > 0 ? 1.5 : -1.5) * 2 * gameSpeedFactor; player.vx = (dx > 0 ? 4 : -4) * gameSpeedFactor; } } } /* updateUI(); // Original call to empty function, can be removed or used if updateUI is populated */ }
        function updatePlatforms(){ for(let i=platforms.length-1; i>=0; i--){ const p=platforms[i]; if(!p.static&&!p.deadly&&p.type!=='ocean_floor'){ let oldDirection=p.direction;p.x+=p.direction*p.speed;if(p.x<=0||p.x+p.width>=TARGET_CANVAS_WIDTH){p.direction*=-1;p.x=Math.max(0,Math.min(p.x,TARGET_CANVAS_WIDTH-p.width));if(oldDirection!==p.direction){for(const enemy of enemies){if(enemy.platformAttached===p && enemy.type==='angler')enemy.direction=p.direction;}}}} if(p.type==='disappearing_coral'&&p.active){ if(player.isAttached&&player.attachedPlatform===p){p.timer--;}if(p.timer<=0){p.active=false;if(player.isAttached&&player.attachedPlatform===p){player.isAttached=false;player.attachedPlatform=null;player.vy=BUOYANCY*4;}setTimeout(()=>{p.active=true;p.originalColor1&&(p.color1=p.originalColor1);p.timer=Math.floor(80/gameSpeedFactor);},p.reappearTime);}} if (p.type === 'retracting_coral' && p.isRetracted) { p.retractTimer--; p.retractedPercent = 1 - (p.retractTimer / p.maxRetractTime); p.retractedPercent = Math.max(0, Math.min(1, p.retractedPercent)); if (p.retractTimer <= 0) { p.isRetracted = false; p.active = true; p.retractedPercent = 0; } } if (p.hasLurker) { if (p.lurkerState === 'firing') { p.lurkerFireTimer--; p.lurkerInkCloudRadius += p.lurkerMaxInkCloudRadius / p.lurkerFireTime; if (frameCount % 3 === 0) { emitParticles(p.x + p.width/2, p.y + p.height + 5, 'lurker_ink_cloud'); } if (p.lurkerFireTimer <= 0) { if (player.isAttached && player.attachedPlatform === p && !player.invincible && player.canTakeDamage) { const distToPlayer = Math.sqrt(Math.pow(player.x - (p.x + p.width/2), 2) + Math.pow(player.y - (p.y + p.height), 2)); if (distToPlayer < p.lurkerInkCloudRadius) { player.inkedTimer = 20; playerDie("lurker_bite"); player.vy = (BUOYANCY > 0 ? 1.0 : -1.0) * 1.2 * gameSpeedFactor; } } p.lurkerState = 'cooldown'; p.lurkerCooldownTimer = p.lurkerCooldownTime; p.lurkerChargeTime = 0; p.lurkerInkCloudRadius = 0; } } else if (p.lurkerState === 'cooldown') { p.lurkerCooldownTimer--; if (p.lurkerCooldownTimer <= 0) { p.lurkerState = 'idle'; } } else if (p.lurkerState === 'warning' || p.lurkerState === 'idle') { if (player.attachedPlatform !== p || !player.isAttached) { if(p.lurkerState !== 'idle') { p.lurkerState = 'cooldown'; p.lurkerCooldownTimer = p.lurkerCooldownTime / 2; p.lurkerChargeTime = 0; p.lurkerFireTimer = 0; p.lurkerInkCloudRadius = 0; } } } } } }
        function updateEnemies(){ for(let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (enemy.type === 'angler') { if(!enemy.platformAttached||!enemy.platformAttached.active){enemy.speed*=0.95; enemy.y += BUOYANCY*0.5; if(enemy.y < -enemy.size*2) enemies.splice(i,1); continue;} const pa=enemy.platformAttached;enemy.x+=enemy.direction*enemy.speed;const patrolMargin=5;if(enemy.x-enemy.size<pa.x+patrolMargin||enemy.x+enemy.size>pa.x+pa.width-patrolMargin){enemy.direction*=-1;enemy.x=Math.max(pa.x+patrolMargin+enemy.size,Math.min(enemy.x,pa.x+pa.width-patrolMargin-enemy.size));}enemy.y=pa.y+pa.height+enemy.size+5; enemy.angle += 0.008 * gameSpeedFactor * enemy.direction; } else if (enemy.type === 'jellyfish') { enemy.update(); } if (enemy.pushedBySonarTimer && enemy.pushedBySonarTimer > 0) { enemy.x += enemy.speedX; enemy.y += enemy.speedY; enemy.speedX *= 0.9; enemy.speedY *= 0.9; enemy.pushedBySonarTimer--; } } }
        function updateStars(){ stars.forEach(star=>{if(!star.collected){star.bobOffset+=star.bobSpeed;}})}
        function updatePowerUps(){ powerUps.forEach(pu => { if(!pu.collected) pu.update();})} 
        function updateGameEffectParticles(){ for(let i=gameEffectParticles.length-1;i>=0;i--){gameEffectParticles[i].update();if(gameEffectParticles[i].lifetime<=0||gameEffectParticles[i].size<=0.1){gameEffectParticles.splice(i,1);}}}
        function updateAmbientBubbles(){ for(const b of ambientBubbles){ b.update(); } for(const b of foregroundBubbles){ b.update(); } }
        function playerDie(reason="unknown"){ if(player.invincible && !reason.includes("surfaced") && reason !== "fell_off_bottom") return; if(!player.canTakeDamage && !player.invincible && !reason.includes("surfaced") && reason !== "fell_off_bottom") return; player.lives--; playLifeLostSound(); /* updateUI(); // Original call to empty function */ if (reason === "lurker_bite") { playLurkerImpactSound(); } if(player.lives<=0){ gameOver=true; gameOverFinalAir=airCollected; if(airCollected>totalAirHighScore){totalAirHighScore=airCollected;localStorage.setItem('abyssalAscentTotalAir_v22',totalAirHighScore);} playerCanMove=false; gameState='transitioning'; transitionCallback=()=>{gameState='gameOver';playGameOverSound();updateUIVisibility();}; }else{ playerCanMove=false; gameState='transitioning'; transitionCallback=()=>{ if(platforms.length>0&&platforms[0].type==='start_ceiling'){ player.x=platforms[0].x+platforms[0].width/2; player.y=platforms[0].y+platforms[0].height+player.radius+40; player.isAttached=false;player.attachedPlatform=null; }else{ player.x=TARGET_CANVAS_WIDTH/2;player.y=TARGET_CANVAS_HEIGHT-100;player.isAttached=false; } player.vx=0;player.vy=0; player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL; player.invincible=true;player.invincibleTimer=Math.floor(120/gameSpeedFactor); player.inkedTimer = 0; updateUIVisibility(); }; } }
        function checkExitPlatform(){
            if(exitPlatform&&player.isAttached&&player.attachedPlatform===exitPlatform){
                if(gameState==='playing'){
                    airCollected+=100*internalLevel;currentDepth-=DEPTH_DECREASE_PER_LEVEL;
                    if(currentDepth<=0){
                        currentDepth=0;gameState='transitioning';playerCanMove=false;
                        transitionCallback=()=>{gameState='gameWon';playGameWonSound();if(airCollected>totalAirHighScore){totalAirHighScore=airCollected;localStorage.setItem('abyssalAscentTotalAir_v22',totalAirHighScore);}updateUIVisibility();};return;
                    }
                    playLevelCompleteSound();playerCanMove=false;gameState='transitioning';
                    transitionCallback=()=>{
                        internalLevel++;
                        platformBaseSpeed += 0.003 * gameSpeedFactor; 
                        platformBaseSpeed = Math.min(platformBaseSpeed, (0.42 * gameSpeedFactor) * 2.5); 
                        player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL;
                        initLevel();updateUIVisibility();
                    };
                }
            }
        }
        function drawBackground(){ const grad=ctx.createLinearGradient(0,0,0,TARGET_CANVAS_HEIGHT);currentGradientColors.forEach((c,i)=>{grad.addColorStop(i/(currentGradientColors.length-1),c);});ctx.fillStyle=grad;ctx.fillRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT);}
        function drawGameElements(){ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} strongCurrents.forEach(c => c.draw(ctx)); if (internalLevel === 1) { seaFloorKelps.forEach(kelp => kelp.draw(ctx)); } for(const p of platforms){if(p.active || (p.type === 'retracting_coral' && p.isRetracted) ) drawPlatform(p); if (p.hasLurker && p.lurkerState === 'firing' && p.lurkerInkCloudRadius > 0) { ctx.fillStyle = `rgba(20, 20, 25, ${0.6 * (p.lurkerFireTimer / p.lurkerFireTime)})`; ctx.beginPath(); ctx.arc(p.x + p.width/2, p.y + p.height + 5, p.lurkerInkCloudRadius, 0, Math.PI*2); ctx.fill(); } } if(exitPlatform){ drawPlatform(exitPlatform); ctx.fillStyle='white';ctx.strokeStyle='#104010';ctx.lineWidth=2;ctx.font='bold 14px Arial';ctx.textAlign='center'; ctx.strokeText('ASCENT',exitPlatform.x+exitPlatform.width/2,exitPlatform.y+exitPlatform.height/2+5); ctx.fillText('ASCENT',exitPlatform.x+exitPlatform.width/2,exitPlatform.y+exitPlatform.height/2+5); } if(internalLevel===1 && seaFloorDecorations.length > 0){ for(const decor of seaFloorDecorations){ctx.fillStyle=decor.color;ctx.fillRect(decor.x-decor.w/2,decor.baseY-decor.h,decor.w,decor.h);}} for(const gem of stars){if(!gem.collected)drawGem(gem.x,gem.y+Math.sin(gem.bobOffset+frameCount*gem.bobSpeed)*3,gem.radius,gem.scale);} for(const pu of powerUps){if(pu && typeof pu.draw === 'function') pu.draw(ctx);} for(const enemy of enemies){ if (enemy.type === 'angler') drawAnglerFish(enemy); else if (enemy.type === 'jellyfish') enemy.draw(ctx); } let pC1='#70C1FF',pC2='#2A7AB0'; if(player.inkedTimer > 0 && Math.floor(player.inkedTimer/3)%2 === 0) { pC1 = '#303035'; pC2 = '#101015'; } else if(player.speedBoost && Math.floor(player.speedBoostTimer / 5) % 2 === 0) { pC1='hsl(120, 70%, 75%)';pC2='hsl(140, 70%, 55%)'; } else if(player.invincibleTimer>0&&Math.floor(player.invincibleTimer/5)%2===0){ pC1='hsl(50, 100%, 85%)';pC2='hsl(45, 100%, 65%)'; } drawCircleWithGradient(player.x,player.y,player.radius,pC1,pC2,player.scale); if (player.sonarPulseActive && player.sonarPulseRadius > 0) { ctx.strokeStyle = `rgba(200, 150, 255, ${0.6 * (player.sonarPulseTimer / (180/gameSpeedFactor))})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(player.x, player.y, player.sonarPulseRadius, 0, Math.PI * 2); ctx.stroke(); } if(player.isAttached&&player.attachedPlatform){ ctx.strokeStyle='rgba(220,240,255,0.4)';ctx.lineWidth=player.radius*0.12;ctx.beginPath();ctx.moveTo(player.x,player.y-player.radius);ctx.lineTo(player.x,player.attachedPlatform.y+player.attachedPlatform.height);ctx.stroke(); } else{ ctx.fillStyle='rgba(220,240,255,0.15)';ctx.beginPath();ctx.arc(player.x-player.radius*0.35,player.y-player.radius*0.35,player.radius*0.2,0,Math.PI*2);ctx.fill();} for(const p of gameEffectParticles){if(p&&typeof p.draw==='function')p.draw(ctx);} for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} const infoTxt=`Air: ${airCollected} | Depth: ${currentDepth}m | Bubbles: ${player.lives}`;ctx.fillStyle='white';ctx.strokeStyle='black';ctx.lineWidth=2.5;ctx.font='bold 17px Arial';ctx.textAlign='left';ctx.strokeText(infoTxt,10,30);ctx.fillText(infoTxt,10,30); }
        function drawStartScreen(){ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} drawScreenMessage("ABYSSAL ASCENT","Press PUSH to Detach & Ascend",'#A7FFEB','white',30,18); ctx.font='bold 13px Arial';ctx.lineWidth=2;ctx.fillStyle='white';ctx.strokeStyle='black'; ctx.strokeText("Arrow Keys: Move Along Ceiling | SPACE/Button: PUSH Down",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+55); ctx.fillText("Arrow Keys: Move Along Ceiling | SPACE/Button: PUSH Down",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+55); ctx.strokeText("Collect Air Bubbles, reach the Surface Exit.",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+75); ctx.fillText("Collect Air Bubbles, reach the Surface Exit.",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+75); for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);}  }
        function drawScreenMessage(title,msg,tc,mc,ts,ms){ ctx.fillStyle=tc;ctx.strokeStyle='black';ctx.lineWidth=4;ctx.font=`bold ${ts}px Arial`;ctx.textAlign='center';ctx.strokeText(title,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2-25);ctx.fillText(title,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2-25);if(msg){ctx.fillStyle=mc;ctx.font=`bold ${ms}px Arial`;ctx.lineWidth=3;ctx.strokeText(msg,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+25);ctx.fillText(msg,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+25);}}
        function drawGameOverScreen(){ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} drawScreenMessage("LOST TO THE ABYSS",`Total Air: ${gameOverFinalAir}`,'#FF8A80','white',36,22); ctx.fillStyle='white';ctx.strokeStyle='black';ctx.lineWidth=3;ctx.font='bold 24px Arial';ctx.textAlign='center'; ctx.strokeText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.fillText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.font='bold 19px Arial';ctx.strokeText('Press PUSH to Try Again',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); ctx.fillText('Press PUSH to Try Again',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);}  }
        function drawGameWonScreen(){ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} drawScreenMessage("SURFACE REACHED!",`Total Air: ${airCollected}`,'#81C784','white',38,24); ctx.fillStyle='white';ctx.strokeStyle='black';ctx.lineWidth=3;ctx.font='bold 24px Arial';ctx.textAlign='center'; ctx.strokeText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.fillText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.font='bold 19px Arial';ctx.strokeText('Press PUSH to Dive Again!',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); ctx.fillText('Press PUSH to Dive Again!',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);}  }
        function drawTransitionOverlay(){ ctx.fillStyle=`rgba(0,5,10,${transitionAlpha})`;ctx.fillRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT);}
        function draw(){ if (gameState !== 'paused') { ctx.clearRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT); if(gameState==='start'){ drawStartScreen(); } else if(gameState==='playing'||gameState==='levelComplete'||gameState==='transitioning'){ drawGameElements(); } else if(gameState==='gameOver'){ drawGameOverScreen(); } else if(gameState==='gameWon'){ drawGameWonScreen(); } else { ctx.fillStyle='#AA0000';ctx.fillRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT); ctx.fillStyle='yellow';ctx.fillRect(20,20,60,60); ctx.fillStyle='white';ctx.font='14px Arial';ctx.fillText(`Unknown GS: ${gameState}`,20,100); console.error("DRAW IN UNKNOWN GAMESTATE:",gameState); } if (foregroundBubbles && foregroundBubbles.length > 0) { for (const b of foregroundBubbles) { if (b && typeof b.draw === 'function') b.draw(ctx); } } if(gameState==='transitioning'){ drawTransitionOverlay(); } } }
        function resetGame(isFullResetFromMenuOrGameOver = false){ if(isFullResetFromMenuOrGameOver){ player.lives=3;airCollected=0;currentDepth=STARTING_DEPTH;internalLevel=1; platformBaseSpeed = 0.42 * gameSpeedFactor; gradientBaseHue=200; player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL; totalAirHighScore=parseInt(localStorage.getItem('abyssalAscentTotalAir_v22')||'0',10); } initLevel(isFullResetFromMenuOrGameOver); gameState='playing'; playerCanMove=true; player.canTakeDamage=true;clearTimeout(player.damageCooldownTimeout); player.invincible=false;player.invincibleTimer=0; player.speedBoost=false;player.speedBoostTimer=0; player.sonarPulseActive = false; player.sonarPulseTimer = 0; player.inkedTimer = 0; transitionAlpha=0;transitionSpeed=Math.abs(transitionSpeed);transitionCallback=null; gameEffectParticles=[]; attemptPlayMusic(); updateUIVisibility(); gameOver=false; }
        let frameCount=0; function gameLoop(timestamp){ update(); draw(); frameCount++; requestAnimationFrame(gameLoop); }
        
        initLevel(true); // Initializes game state, calls resetGame, which calls updateUIVisibility
        prepareMusic();
        // updateUIVisibility(); // Called within resetGame, which is called by initLevel.
        gameLoop();
    </script>
</body>
</html>
