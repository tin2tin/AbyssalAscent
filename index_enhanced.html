<!DOCTYPE html>
<html>
<head>
    <title>Abyssal Ascent - Polished Depths</title>
    <style>
        body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background: #000000; overflow: hidden; font-family: sans-serif; user-select: none; touch-action: pan-y; }
        #game-super-container { position: relative; display: flex; justify-content: center; align-items: center; flex-grow: 1; width: 100%; overflow: hidden; }
        canvas {
            max-width: 100%;
            max-height: 100%;
            border: 2px solid #00111a;
            background: #000000;
            display: block;
            aspect-ratio: 600 / 900;
            object-fit: contain;
            touch-action: none;
        }
        #top-right-controls { position: absolute; top: 10px; right: 10px; left: auto; z-index: 100; display: none; }
        #pause-button { padding: 8px 15px; background: linear-gradient(to bottom, #4A6B7E, #3A5060); border: 2px solid #1C2A34; border-radius: 5px; color: white; cursor: pointer; font-family: sans-serif; font-size: 16px; white-space: nowrap; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); user-select: none; touch-action: manipulation; }
        #pause-button:active { background: linear-gradient(to bottom, #3A5060, #4A6B7E); box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5); }
        #mobile-controls-container { position: absolute; bottom: 0; left: 0; width: 100%; z-index: 10; }
        #mobile-controls { display: none; width: 100%; max-width: 600px; margin: 0 auto; padding: 10px 5px; box-sizing: border-box; justify-content: space-between; align-items: flex-end; }
        #mobile-controls .control-group { display: flex; gap: 25px; }
        #mobile-controls button { width: 180px; height: 180px; display: flex; justify-content: center; align-items: center; background: linear-gradient(to bottom, #20B2AA, #008080); border: 2px solid #004D40; border-radius: 50%; color: white; font-size: 30px; font-weight: bold; cursor: pointer; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); user-select: none; touch-action: manipulation; text-align: center; line-height: 1; }
        #mobile-controls button:active { background: linear-gradient(to bottom, #008080, #20B2AA); box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5); }
        #pause-menu { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,10,20,0.9); z-index: 200; flex-direction: column; justify-content: center; align-items: center; color: #E0F7FA; font-size: 24px; }
        #pause-menu h2 { font-size: 4em; margin-bottom: 30px; color: #FFEB3B; text-shadow: 2px 2px 5px rgba(0,0,0,0.7); }
        #pause-menu button { padding: 15px 30px; margin: 10px 0; font-size: 1.5em; background: linear-gradient(to bottom, #20B2AA, #008080); border: 2px solid #004D40; border-radius: 8px; color: white; cursor: pointer; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); user-select: none; touch-action: manipulation; }
        #pause-menu button:active { background: linear-gradient(to bottom, #008080, #20B2AA); box-shadow: inset 1px 1px 3px rgba(0,0,0,0.5); }
        #close-app-button { background: linear-gradient(to bottom, #E57373, #C62828) !important; }
        #close-app-button:active { background: linear-gradient(to bottom, #C62828, #E57373) !important; }
    </style>
</head>
<body>
    <div id="game-super-container">
        <div id="top-right-controls"><button id="pause-button">PAUSE</button></div>
        <canvas id="gameCanvas"></canvas>
        <div id="mobile-controls-container">
            <div id="mobile-controls"> <div class="control-group"> <button id="left-btn">LEFT</button> <button id="right-btn">RIGHT</button> </div> <button id="jump-btn">PUSH</button> </div>
        </div>
    </div>
    <div id="pause-menu"> <h2>PAUSED</h2> <button id="resume-button">Resume Ascent</button> <button id="restart-from-pause">New Ascent</button> <button id="mute-button-from-pause">Mute Echoes</button> <button id="close-app-button">Return to Surface</button> </div>

    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const TARGET_CANVAS_WIDTH = 600; const TARGET_CANVAS_HEIGHT = 900;
        canvas.width = TARGET_CANVAS_WIDTH; canvas.height = TARGET_CANVAS_HEIGHT;
        const isAndroid = /Android/i.test(navigator.userAgent);
        
        const gameSpeedFactor = isAndroid ? 0.5 : 1.0;

        const BUOYANCY = -0.12 * gameSpeedFactor; 
        const PLAYER_BASE_SPEED = 2.6 * gameSpeedFactor; 
        const PLAYER_BASE_PUSH_INITIAL = 9.0 * gameSpeedFactor; 
        const WATER_RESISTANCE_V = 0.97;
        const WATER_RESISTANCE_H_NORMAL = 0.96;
        const WATER_RESISTANCE_H_SLIPPERY = 0.992; 
        const PLATFORM_ATTACH_PULL_UP = 0.30 * gameSpeedFactor; 

        const MIN_CEILING_UNDERSIDE_GAP_FACTOR = 0.35;
        const MAX_CEILING_UNDERSIDE_GAP_FACTOR = 0.40; 

        const BOTTOM_DEATH_FLOOR_HEIGHT = 20;
        const EXIT_CEILING_HEIGHT = 25; const TOP_SURFACE_DEATH_Y = 10;
        const EXIT_CEILING_UNDERSIDE_Y = TOP_SURFACE_DEATH_Y + EXIT_CEILING_HEIGHT + 25;
        const PLATFORM_CORNER_RADIUS = 10;
        const STARTING_DEPTH = 1000; const DEPTH_DECREASE_PER_LEVEL = 7;

        const keys = {};
        window.addEventListener('keydown', e => { /* ... (original key listener) ... */ keys[e.key] = true; const keyLower = e.key.toLowerCase(); if (keyLower === ' ') { if (gameState !== 'playing' && gameState !== 'paused') { e.preventDefault(); } } else if (keyLower === 'p' || keyLower === 'escape') { if (gameState === 'playing' || gameState === 'gameOver' || gameState === 'gameWon') { e.preventDefault(); } } });
        window.addEventListener('keyup',e=>keys[e.key]=false);

        const topRightControls=document.getElementById('top-right-controls');const mobileControls=document.getElementById('mobile-controls');const pauseMenu=document.getElementById('pause-menu');const pauseButton=document.getElementById('pause-button');const resumeButton=document.getElementById('resume-button');const closeAppButton=document.getElementById('close-app-button');const restartFromPauseButton=document.getElementById('restart-from-pause');const muteButtonFromPause=document.getElementById('mute-button-from-pause');const leftBtn=document.getElementById('left-btn');const rightBtn=document.getElementById('right-btn');const jumpBtn=document.getElementById('jump-btn');

        let player={x:50,y:50,radius:15,baseRadius:15,maxRadius:26,radiusGrowthPerStar:0.25,vx:0,vy:0,isAttached:false,lives:3,scale:1,canTakeDamage:true,damageCooldownTimeout:null,invincible:false,invincibleTimer:0,speedBoost:false,speedBoostTimer:0,baseSpeed:PLAYER_BASE_SPEED,currentPushForce: PLAYER_BASE_PUSH_INITIAL,attachedPlatform:null, temporaryDragTimer: 0, temporaryDragForce: 0, sonarPulseActive: false, sonarPulseTimer: 0, sonarPulseRadius: 0, sonarPulseMaxRadius: 150, sonarPulseCount: 0};
        let platforms=[];let enemies=[];let stars=[];let powerUps=[];let gameEffectParticles=[];
        let strongCurrents = [];
        let ambientBubbles=[]; let foregroundBubbles = [];
        let exitPlatform=null;
        let airCollected=0; let internalLevel=1; let currentDepth = STARTING_DEPTH;
        let gameState='start';
        let platformBaseSpeed = 0.42 * gameSpeedFactor;
        let currentGradientColors=['#000000','#000000','#000000']; let gradientBaseHue = 200;
        let totalAirHighScore=parseInt(localStorage.getItem('abyssalAscentTotalAir_v14')||'0',10); // Version bump
        let gameOverFinalAir=0;let transitionAlpha=0;let transitionSpeed=0.03;let transitionCallback=null;let playerCanMove=false;let gameOver=false; let justRestartedFromGameOver = false;
        const SPECIAL_PLATFORM_TYPES=['disappearing_coral','bouncy_vent','conveyor_current', 'retracting_coral', 'slippery_kelp_patch'];
        const PLATFORM_VISUAL_THEMES = ['rock_formation', 'ancient_coral_shelf', 'dense_kelp_bed', 'sunken_driftwood', 'rusted_shipwreck_panel'];
        let seaFloorDecorations = [];

        function updateUI(){}
        function updateUIVisibility(){ /* ... (original visibility) ... */ const showMobile=isAndroid&& (gameState==='start'||gameState==='playing'||gameState==='gameOver'||gameState==='gameWon'||gameState==='transitioning');mobileControls.style.display=showMobile?'flex':'none';if(gameState==='start'||gameState==='gameOver'||gameState==='gameWon'){topRightControls.style.display='block';pauseMenu.style.display='none';}else if(gameState==='playing'||gameState==='transitioning'){topRightControls.style.display='block';pauseMenu.style.display='none';}else if(gameState==='paused'){topRightControls.style.display='none';pauseMenu.style.display='flex';}}
        let audioContext;let abyssalDroneMusic;let cyclingPlatformsMusic;let isMuted=false;
        function createOscillatorSound(f,duration,t,pStartTime=0, vol=0.18, attackTime=0.001, decayTime=0.1, sustainLevel=0.001) { /* ... (original sound creation) ... */ if(isMuted)return; if(gameState!=='playing'&&gameState!=='levelComplete'&&gameState!=='gameWon'&&gameState!=='start')return; if(!isFinite(f)||!isFinite(duration)||!isFinite(pStartTime)){console.error("Non-finite audio param:",{f,duration,pStartTime});return;} if(!audioContext){try{audioContext=new(window.AudioContext||window.webkitAudioContext)();}catch(e){console.warn("No AudioCtx");return;}} if(!audioContext)return; const actualStartTime=audioContext.currentTime+pStartTime; const osc=audioContext.createOscillator();const gain=audioContext.createGain(); osc.type=t; osc.frequency.setValueAtTime(f,actualStartTime); gain.gain.setValueAtTime(0, actualStartTime); gain.gain.linearRampToValueAtTime(vol, actualStartTime + attackTime); gain.gain.setValueAtTime(vol, actualStartTime + duration - decayTime); gain.gain.linearRampToValueAtTime(sustainLevel, actualStartTime + duration); osc.connect(gain);gain.connect(audioContext.destination); osc.start(actualStartTime);osc.stop(actualStartTime+duration + 0.05); }
        
        function playPushFromCeilingSound(){ createOscillatorSound(80, 0.25, 'sine', 0, 0.2, 0.01, 0.2); createOscillatorSound(100, 0.15, 'square', 0.02, 0.1, 0.01, 0.1); emitParticles(player.x,player.y-player.radius,'push_down_burst');}
        function playAttachToCeilingSound(){ createOscillatorSound(250, 0.15, 'sine', 0, 0.15, 0.02, 0.1); createOscillatorSound(150, 0.1, 'triangle', 0.03, 0.1, 0.01, 0.08); emitParticles(player.x,player.y-player.radius,'attach_clink');}
        
        // MODIFIED: Gem/Air pickup sound
        function playGemSound(){ 
            // Brief "whoosh" (simulated with fast pitch sweep)
            if (audioContext) {
                const now = audioContext.currentTime;
                const noiseOsc = audioContext.createOscillator();
                const noiseGain = audioContext.createGain();
                noiseOsc.type = 'square'; // Noise-like with square/sawtooth
                noiseOsc.frequency.setValueAtTime(1500, now);
                noiseOsc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                noiseGain.gain.setValueAtTime(0.08, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                noiseOsc.connect(noiseGain); noiseGain.connect(audioContext.destination);
                noiseOsc.start(now); noiseOsc.stop(now + 0.13);
            }
            // Soft pop/bubble
            createOscillatorSound(600, 0.15, 'sine', 0.05, 0.1, 0.005, 0.1); 
            emitParticles(player.x,player.y,'gem_shine');
        }

        function playBouncyVentSound(){ createOscillatorSound(150, 0.35, 'sine', 0, 0.2, 0.05, 0.25); createOscillatorSound(600, 0.2, 'triangle', 0.05, 0.1, 0.02, 0.15); emitParticles(player.x,player.y-player.radius,'geyser_burst');}
        function playLifeLostSound(){ createOscillatorSound(70, 0.5, 'sine', 0, 0.25, 0.05, 0.4); createOscillatorSound(90, 0.4, 'square', 0.1, 0.15, 0.05, 0.3);}
        function playLevelCompleteSound(){ createOscillatorSound(330, 0.25, 'sine', 0, 0.15, 0.03, 0.2); createOscillatorSound(440, 0.25, 'sine', 0.15, 0.15, 0.03, 0.2); createOscillatorSound(523.25, 0.25, 'sine', 0.3, 0.15, 0.03, 0.2);}
        function playGameOverSound(){ createOscillatorSound(150, 0.6, 'sine', 0, 0.2, 0.1, 0.45); createOscillatorSound(75, 0.7, 'sine', 0.2, 0.18, 0.1, 0.55);}
        function playPowerUpSound(type){ let baseFreq = 300, secondFreq = 400, waveform = 'triangle', dur = 0.25, vol = 0.15; if(type==='extra_life') { baseFreq=500; secondFreq=650; waveform='sine'; dur=0.35; vol=0.18;} else if (type === 'sonar_pulse') { baseFreq=200; secondFreq=100; waveform='sine'; dur=0.4; vol=0.2;} createOscillatorSound(baseFreq, dur, waveform, 0, vol, 0.02, dur*0.8); if (type !== 'sonar_pulse') createOscillatorSound(secondFreq, dur, waveform, 0.05, vol*0.7, 0.02, dur*0.8); } 
        function playGameWonSound(){ createOscillatorSound(392, 0.3, 'sine', 0, 0.18, 0.05, 0.25); createOscillatorSound(523.25, 0.3, 'sine', 0.15, 0.18, 0.05, 0.25); createOscillatorSound(659.25, 0.35, 'sine', 0.3, 0.18, 0.05, 0.3); }
        function playJellyfishZapSound(){ createOscillatorSound(180, 0.2, 'square', 0, 0.15, 0.01, 0.15); createOscillatorSound(130, 0.15, 'square', 0.03, 0.1, 0.01, 0.1);}
        function playJellyfishBounceSound(){ createOscillatorSound(200, 0.2, 'sine', 0, 0.18, 0.01, 0.15); if(!audioContext) return; const osc = audioContext.createOscillator(); const gain = audioContext.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(250, audioContext.currentTime); osc.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.15); gain.gain.setValueAtTime(0.15, audioContext.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15); osc.connect(gain); gain.connect(audioContext.destination); osc.start(); osc.stop(audioContext.currentTime + 0.16);}
        function playJellyfishPushedSound(){ createOscillatorSound(100, 0.25, 'sine', 0, 0.15, 0.02, 0.2); createOscillatorSound(150, 0.15, 'square', 0.03, 0.08, 0.01, 0.1); }
        function playLurkerWarningSound(){ createOscillatorSound(120, 0.2, 'sawtooth', 0, 0.12, 0.01, 0.18); createOscillatorSound(100, 0.15, 'square', 0.05, 0.1, 0.01, 0.13);}
        function playLurkerBiteSound(){ createOscillatorSound(90, 0.25, 'sawtooth', 0, 0.2, 0.005, 0.2); createOscillatorSound(140, 0.1, 'square', 0.01, 0.15, 0.005, 0.08);}
        function playRetractPlatformSound(){ createOscillatorSound(150, 0.35, 'sawtooth', 0, 0.15, 0.05, 0.25); createOscillatorSound(100, 0.3, 'square', 0.08, 0.1, 0.05, 0.2); } 
        function playSonarPulseFireSound(){ createOscillatorSound(300, 0.3, 'sine', 0, 0.22, 0.01, 0.25); }

        muteButtonFromPause.addEventListener('click',toggleMute);function toggleMute(){ /* ... (original mute) ... */ isMuted=!isMuted;muteButtonFromPause.textContent=isMuted?'Unmute Sounds':'Mute Sounds';if(abyssalDroneMusic){abyssalDroneMusic.muted=isMuted;if(isMuted&&!abyssalDroneMusic.paused)abyssalDroneMusic.pause();}if(cyclingPlatformsMusic){cyclingPlatformsMusic.muted=isMuted;if(isMuted&&!cyclingPlatformsMusic.paused)cyclingPlatformsMusic.pause();}if(!isMuted&&(gameState==='playing'||gameState==='start'||gameState==='gameWon')){attemptPlayMusic();}}
        function prepareMusic(){ /* ... (original music prep) ... */ if(!abyssalDroneMusic){try{abyssalDroneMusic=new Audio('audio/Abyssal_Drone.mp3');abyssalDroneMusic.loop=true;abyssalDroneMusic.volume=0.3;abyssalDroneMusic.muted=isMuted;}catch(e){console.warn("No drone music",e);abyssalDroneMusic=null;}}if(!cyclingPlatformsMusic){try{cyclingPlatformsMusic=new Audio('audio/Cycling_Platforms.mp3');cyclingPlatformsMusic.loop=true;cyclingPlatformsMusic.volume=0.25;cyclingPlatformsMusic.muted=isMuted;}catch(e){console.warn("No cycling music",e);cyclingPlatformsMusic=null;}}}
        function attemptPlayMusic(){ /* ... (original music attempt) ... */ prepareMusic();if(abyssalDroneMusic&&!isMuted&&abyssalDroneMusic.paused){abyssalDroneMusic.play().catch(e=>console.error("Drone Music fail:",e));}if(cyclingPlatformsMusic&&!isMuted&&cyclingPlatformsMusic.paused){cyclingPlatformsMusic.play().catch(e=>console.error("Cycling Music fail:",e));}}
        setupTouchControl(leftBtn,'ArrowLeft');setupTouchControl(rightBtn,'ArrowRight');setupTouchControl(jumpBtn,' ');function setupTouchControl(btn,key){ /* ... (original touch controls) ... */ btn.addEventListener('touchstart',(e)=>{e.preventDefault();keys[key]=true;if(key===' '&&gameState==='start'){attemptPlayMusic();gameState='playing';playerCanMove=true;updateUIVisibility();keys[' ']=false;}else if(key===' '&&(gameState==='gameOver'||gameState==='gameWon')){attemptPlayMusic();resetGame(true);keys[' ']=false;justRestartedFromGameOver=true;}},{passive:false});btn.addEventListener('touchend',(e)=>{e.preventDefault();keys[key]=false;},{passive:false});btn.addEventListener('mousedown',()=>{keys[key]=true;if(key===' '&&gameState==='start'){attemptPlayMusic();gameState='playing';playerCanMove=true;updateUIVisibility();keys[' ']=false;}else if(key===' '&&(gameState==='gameOver'||gameState==='gameWon')){attemptPlayMusic();resetGame(true);keys[' ']=false;justRestartedFromGameOver=true;}});btn.addEventListener('mouseup',()=>{keys[key]=false;});btn.addEventListener('mouseleave',()=>{keys[key]=false;});}
        pauseButton.addEventListener('click', () => { /* ... (original pause button) ... */ if (gameState === 'playing') { gameState = 'paused'; if (abyssalDroneMusic) abyssalDroneMusic.pause(); if (cyclingPlatformsMusic) cyclingPlatformsMusic.pause(); playerCanMove = false; updateUIVisibility(); } else if (gameState === 'gameOver' || gameState === 'gameWon') { attemptPlayMusic(); resetGame(true); } });
        resumeButton.addEventListener('click',()=>{ /* ... (original resume) ... */ if(gameState==='paused'){gameState='playing';attemptPlayMusic();playerCanMove=true;updateUIVisibility();}});
        restartFromPauseButton.addEventListener('click',()=>{ /* ... (original restart from pause) ... */ if(gameState==='paused'||confirm("New Ascent? This will reset your Air Collected and current Depth.")){resetGame(true);}});
        closeAppButton.addEventListener('click',()=>{ /* ... (original close app) ... */ if(window.AndroidInterface&&typeof window.AndroidInterface.closeApp==='function'){window.AndroidInterface.closeApp();}else{alert("Cannot close.");}});

        class GameEffectParticle{ /* ... (original particle class) ... */ constructor(x,y,type,color,size,vx,vy,lifetime){this.x=x;this.y=y;this.type=type;this.color=color;this.size=size;this.vx=vx*gameSpeedFactor;this.vy=vy*gameSpeedFactor;this.alpha=1;this.lifetime=lifetime/gameSpeedFactor;this.originalLifetime=this.lifetime;this.buoyancyEffect=(type==='push_down_burst'||type==='geyser_burst')?0.09*gameSpeedFactor:((type==='attach_clink')?0.03*gameSpeedFactor:-0.06*gameSpeedFactor);} update(){this.x+=this.vx;this.y+=this.vy;this.vy+=this.buoyancyEffect;this.vy*=0.98;this.vx*=0.98;this.lifetime--;this.alpha=this.lifetime/this.originalLifetime;this.size*=(this.type==='gem_shine'?0.97:0.93);if(this.lifetime<=0||this.size<0.2)this.lifetime=0;} draw(ctx){if(this.lifetime<=0)return;ctx.save();ctx.globalAlpha=this.alpha;ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fill();ctx.restore();}}
        function emitParticles(x,y,type){ /* ... (original emit particles) ... */ let numP,clr,minS,maxS,minVx,maxVx,minVy,maxVy,life;switch(type){case 'gem_shine':numP=6;clr='rgba(200,255,255,0.9)';minS=2;maxS=5;minVx=-1.5;maxVx=1.5;minVy=-1.5;maxVy=1.5;life=35;break;case 'attach_clink':numP=4;clr='rgba(180,180,180,0.6)';minS=3;maxS=6;minVx=-0.5;maxVx=0.5;minVy=0.1;maxVy=0.4;life=25;break;case 'push_down_burst':numP=8;clr='rgba(150,200,255,0.7)';minS=4;maxS=8;minVx=-1.2;maxVx=1.2;minVy=2.5;maxVy=4.5;life=40;break;case 'geyser_burst':numP=12;clr='rgba(200,255,230,0.8)';minS=5;maxS=10;minVx=-1.5;maxVx=1.5;minVy=3.0;maxVy=5.5;life=45;break;default:return;}for(let i=0;i<numP;i++){gameEffectParticles.push(new GameEffectParticle(x+(Math.random()-0.5)*5,y+(Math.random()-0.5)*5,type,clr,minS+Math.random()*(maxS-minS),minVx+Math.random()*(maxVx-minVx),minVy+Math.random()*(maxVy-minVy),life));}}
        class AmbientBubble { /* ... (original AmbientBubble class code) ... */ constructor(isParallaxLayer, type = 'ambient') { this.isParallax = isParallaxLayer; this.type = type; this.reset(); } reset() { if (this.type === 'foreground') { this.radius = 25 + Math.random() * 25; this.x = Math.random() * TARGET_CANVAS_WIDTH; this.y = Math.random() * TARGET_CANVAS_HEIGHT; this.baseSpeedY = -(0.1 + Math.random() * 0.15) * gameSpeedFactor; this.speedY = this.baseSpeedY; this.speedX = (Math.random() - 0.5) * 0.1 * gameSpeedFactor; this.alpha = 0.04 + Math.random() * 0.06; this.color = `rgba(200, 235, 255, ${this.alpha})`; this.isParallax = true; } else { this.radius = this.isParallax ? (3 + Math.random() * 7) : (2 + Math.random() * 4); this.x = Math.random() * TARGET_CANVAS_WIDTH; this.y = Math.random() * (TARGET_CANVAS_HEIGHT * 1.2); this.baseSpeedY = -(this.isParallax ? (0.35 + Math.random() * 0.65) : (0.9 + Math.random() * 2.0)) * gameSpeedFactor; this.speedY = this.baseSpeedY; this.speedX = (Math.random() - 0.5) * (this.isParallax ? 0.25 : 0.45) * gameSpeedFactor; this.alpha = (this.isParallax ? 0.05 : 0.2) + Math.random() * (this.isParallax ? 0.18 : 0.35); this.color = `rgba(170, 220, 255, ${this.alpha})`; } this.stuckTimer = 0; this.platformInfluenceX = 0; } update() { this.y += this.speedY; this.x += this.speedX + this.platformInfluenceX; this.platformInfluenceX *= 0.85; this.speedY *= 0.998; this.speedX *= 0.99; if (this.y < -this.radius * 3) { this.reset(); } if (this.type === 'ambient' && !this.isParallax && this.stuckTimer <= 0) { for (const p of platforms) { if (p.deadly || p.type === 'ocean_floor') continue; const pTop = p.y; const pBottom = p.y + p.height; const pLeft = p.x; const pRight = p.x + p.width; if (this.x + this.radius > pLeft && this.x - this.radius < pRight && this.y + this.radius > pTop && this.y - this.radius < pBottom) { if (Math.abs(this.speedY) > 0.05) { this.speedY *= -0.3; this.y += this.speedY * 2.5; this.stuckTimer = Math.floor(10 + Math.random() * 20 / gameSpeedFactor); } this.platformInfluenceX += (this.x < p.x + p.width / 2 ? -0.1 : 0.1) * gameSpeedFactor; break; } } } if (this.stuckTimer > 0) { this.stuckTimer--; this.speedY = this.baseSpeedY * 0.05; } else { this.speedY = Math.min(this.speedY, this.baseSpeedY); } } draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } }
        class PowerUp{ /* ... (original PowerUp class, already extended) ... */ constructor(x,y,type){ this.x=x;this.y=y;this.type=type;this.radius=14;this.collected=false;this.scale=1;this.symbol='';this.animationTimer=0;this.animationSpeed=0.06*gameSpeedFactor; switch(this.type){ case 'shield_bubble':this.color1='#ADD8E6';this.color2='#87CEEB';this.symbol='SHD';break; case 'propulsion_boost':this.color1='#98FB98';this.color2='#3CB371';this.symbol='BST';break; case 'extra_life':this.color1='#FFB74D';this.color2='#F57C00';this.symbol='+1UP';this.radius=16;break; case 'sonar_pulse':this.color1='#BA68C8';this.color2='#7B1FA2';this.symbol='PULSE';break; } } draw(ctx){ if(this.collected)return; const offsetY=Math.sin(this.animationTimer)*6; drawCircleWithGradient(this.x,this.y+offsetY,this.radius,this.color1,this.color2,this.scale); ctx.fillStyle='black';ctx.strokeStyle='white';ctx.lineWidth=1.5; ctx.font = (this.type === 'extra_life') ? 'bold 10px Arial' : 'bold 11px Arial'; ctx.textAlign='center'; ctx.strokeText(this.symbol,this.x,this.y+offsetY+4);ctx.fillText(this.symbol,this.x,this.y+offsetY+4); } update(){this.animationTimer+=this.animationSpeed;}}
        class AbyssalJellyfish { /* ... (Jellyfish class, already updated for stable visuals) ... */ constructor(x, y) { this.x = x; this.y = y; this.radius = 20 + Math.random() * 10; this.speedX = (Math.random() - 0.5) * 0.4 * gameSpeedFactor; this.speedY = (0.15 + Math.random() * 0.25) * gameSpeedFactor; this.colorLight = `hsla(${180 + Math.random()*60}, 70%, 70%, 0.4)`; this.colorDark = `hsla(${190 + Math.random()*60}, 60%, 50%, 0.6)`;  this.type = 'jellyfish'; this.bobOffset = Math.random() * Math.PI * 2; this.bobSpeed = 0.025 * gameSpeedFactor; this.tentacleCount = 6 + Math.floor(Math.random()*4); this.tentacleLengthBase = this.radius * 1.8; this.tentacleSegments = 4; this.pushedTimer = 0; this.pushForceX = 0; this.pushForceY = 0; this.tentaclePhases = []; for(let i=0; i<this.tentacleCount; i++) { this.tentaclePhases.push({ lenFactor: 0.8 + Math.random()*0.4, swayFactor: (Math.random()-0.5) * 20, curveFactor1: (Math.random()-0.5) * 10, curveFactor2: (Math.random()-0.5) * 10, }); } this.innerGlowHue = 180 + Math.random()*60; } update() { if (this.pushedTimer > 0) { this.x += this.pushForceX; this.y += this.pushForceY; this.pushForceX *= 0.92; this.pushForceY *= 0.92; this.pushedTimer--; } else { this.x += this.speedX; this.y += this.speedY; } this.bobOffset += this.bobSpeed; if (this.x + this.radius < -50 || this.x - this.radius > TARGET_CANVAS_WIDTH + 50 || this.y - this.radius > TARGET_CANVAS_HEIGHT + 100 || (this.y + this.radius < -100 && this.speedY <0)) { this.x = Math.random() * TARGET_CANVAS_WIDTH; this.y = (Math.random() < 0.5 ? -this.radius*2 - Math.random()*50 : TARGET_CANVAS_HEIGHT + this.radius*2 + Math.random()*50); this.speedY = (this.y < 0 ? 1 : -1) * (0.15 + Math.random() * 0.25) * gameSpeedFactor; this.speedX = (Math.random() - 0.5) * 0.4 * gameSpeedFactor; } if ((this.x - this.radius < 0 && (this.speedX < 0 || this.pushForceX < 0)) || (this.x + this.radius > TARGET_CANVAS_WIDTH && (this.speedX > 0 || this.pushForceX >0))) { this.speedX *= -0.8; this.pushForceX *= -0.5; this.x = Math.max(this.radius, Math.min(this.x, TARGET_CANVAS_WIDTH - this.radius)); } } draw(ctx) { const drawY = this.y + Math.sin(this.bobOffset * 1.5) * 4; const bellRadius = this.radius; const bellHeight = this.radius * 0.8; ctx.lineWidth = 2; for(let i=0; i < this.tentacleCount; i++) { ctx.beginPath(); let startX = this.x + Math.cos( (i / this.tentacleCount) * Math.PI*2 + this.bobOffset*0.3) * bellRadius * 0.6; let startY = drawY + bellHeight * 0.3 + Math.sin( (i / this.tentacleCount) * Math.PI*2 + this.bobOffset*0.3) * bellRadius * 0.1; ctx.moveTo(startX, startY); let prevX = startX; let prevY = startY; let tPhase = this.tentaclePhases[i]; let tLength = this.tentacleLengthBase * tPhase.lenFactor * (0.9 + Math.sin(this.bobOffset * 2 + i*0.7)*0.1); for (let j = 1; j <= this.tentacleSegments; j++) { let segmentRatio = j / this.tentacleSegments; let controlX = prevX + Math.sin(this.bobOffset * 0.8 + i + j*0.5) * tPhase.curveFactor1 * 0.5; let controlY = prevY + tLength / this.tentacleSegments * 0.5 + Math.cos(this.bobOffset + i + j*0.6) * tPhase.curveFactor2 * 0.5; let endX = startX + Math.sin(this.bobOffset * 0.5 + i * 0.8 + segmentRatio * Math.PI) * tPhase.swayFactor * segmentRatio; let endY = startY + tLength * segmentRatio + Math.cos(this.bobOffset * 1.1 + i*0.5 + segmentRatio * 0.7) * 5; ctx.quadraticCurveTo(controlX, controlY, endX, endY); prevX = endX; prevY = endY; } ctx.strokeStyle = `hsla(${200 + Math.sin(this.bobOffset + i*0.4)*30}, 60%, 70%, 0.5)`; ctx.stroke(); } ctx.beginPath(); ctx.ellipse(this.x, drawY, bellRadius, bellHeight, 0, Math.PI, Math.PI*2, false); ctx.ellipse(this.x, drawY, bellRadius * 0.95, bellHeight * 0.7, 0, 0, Math.PI, false); ctx.closePath(); const grad = ctx.createRadialGradient(this.x, drawY - bellHeight*0.2, bellRadius*0.1, this.x, drawY, bellRadius); grad.addColorStop(0, this.colorLight); grad.addColorStop(1, this.colorDark); ctx.fillStyle = grad; ctx.fill(); ctx.fillStyle = `hsla(${this.innerGlowHue + Math.sin(this.bobOffset*0.7)*10}, 80%, 85%, 0.3)`; ctx.beginPath(); ctx.ellipse(this.x, drawY - bellHeight * 0.1, bellRadius * 0.5, bellHeight * 0.4, 0, 0, Math.PI * 2); ctx.fill(); } }
        class StrongCurrent { /* ... (original current class, already stable) ... */ constructor(y, height, strength) { this.x = 0; this.y = y; this.width = TARGET_CANVAS_WIDTH; this.height = height; this.strength = strength * gameSpeedFactor; this.particles = []; for (let i = 0; i < 30; i++) { this.particles.push({ x: Math.random() * this.width, y: this.y + Math.random() * this.height, size: Math.random() * 2 + 1, alpha: Math.random() * 0.3 + 0.1 }); } } update() { this.particles.forEach(p => { p.x += this.strength * 1.5; if (this.strength > 0 && p.x > this.width) p.x = 0; else if (this.strength < 0 && p.x < 0) p.x = this.width; }); } draw(ctx) { ctx.fillStyle = `rgba(100, 150, 255, 0.08)`; ctx.fillRect(this.x, this.y, this.width, this.height); this.particles.forEach(p => { ctx.fillStyle = `rgba(200, 220, 255, ${p.alpha})`; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); } }
        function drawCircleWithGradient(x,y,r,c1,c2,s=1){ /* ... (original circle gradient) ... */ ctx.beginPath();const gr=ctx.createRadialGradient(x,y,0,x,y,r*s);gr.addColorStop(0,c1);gr.addColorStop(1,c2);ctx.fillStyle=gr;ctx.arc(x,y,r*s,0,Math.PI*2);ctx.fill();ctx.strokeStyle='rgba(0,0,0,0.4)';ctx.lineWidth=1.5;ctx.stroke();}
        
        // MODIFIED: drawPlatform for kelp line fix
        function drawPlatform(platform){
            const {x,y,width,height, type, visualTheme, visualDetails, retractedPercent = 0} = platform;
            ctx.save();
            let effectiveW = width * (1 - retractedPercent * 0.5); 
            let effectiveH = height * (1 - retractedPercent);      
            let effectiveX = x + (width - effectiveW) / 2;

            if (effectiveH < 1 && type === 'retracting_coral') { ctx.restore(); return; } 

            switch(visualTheme) {
                case 'rock_formation': /* ... (rock drawing, already stable) ... */ drawPlatformCeiling_Base(effectiveX,y,effectiveW,effectiveH, platform.color1 || '#607D8B', platform.color2 || '#455A64', PLATFORM_CORNER_RADIUS); if (effectiveH > 5 && visualDetails) { ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1.5; visualDetails.cracks.forEach(crack => { if (retractedPercent < 0.8) { ctx.beginPath(); ctx.moveTo(effectiveX + crack.x1 * effectiveW, y + crack.y1 * effectiveH); ctx.lineTo(effectiveX + crack.x2 * effectiveW, y + crack.y2 * effectiveH); ctx.stroke(); } }); } break;
                case 'ancient_coral_shelf': /* ... (coral drawing, already stable) ... */ const c1 = platform.color1 || '#FF8A65'; const c2 = platform.color2 || '#D84315'; drawPlatformCeiling_Base(effectiveX,y,effectiveW,effectiveH, c1, c2, PLATFORM_CORNER_RADIUS * 1.5); if (effectiveH > 3 && visualDetails) { visualDetails.bumps.forEach(bump => { ctx.fillStyle = bump.c; let r = bump.r * (1-retractedPercent*0.8); if (r > 1) { ctx.beginPath(); ctx.arc(effectiveX + bump.x * effectiveW, y + effectiveH - r * bump.yAnchor, r, 0, Math.PI*2); ctx.fill(); } }); } break;
                case 'dense_kelp_bed': 
                    ctx.fillStyle = '#1B5E20'; 
                    ctx.fillRect(effectiveX,y,effectiveW,effectiveH);
                    if (effectiveH > 10 && visualDetails) { 
                        ctx.strokeStyle = '#4CAF50'; ctx.lineWidth = Math.max(1, 3 * (1-retractedPercent*0.5));
                        // Loop ensures all strands within effectiveW are considered
                        for (let i = 0; i < visualDetails.kelpStrands.length; i++) {
                            const strand = visualDetails.kelpStrands[i];
                            let kxAbsolute = effectiveX + strand.startXOffset * width; // Calculate absolute based on original width
                            let kxAnimated = kxAbsolute + Math.sin(frameCount*0.05 + strand.phase) * 2;
                            
                            // Only draw if the animated kelp base is within the current effective width
                            if (kxAnimated < effectiveX || kxAnimated > effectiveX + effectiveW -2) continue; 
                            
                            let kelpLength = strand.baseLength * (1-retractedPercent*0.7);
                            if (kelpLength < 5) continue;
                            ctx.beginPath();
                            ctx.moveTo(kxAnimated, y + effectiveH); 
                            ctx.bezierCurveTo(kxAnimated - 2, y + effectiveH + kelpLength*0.3, kxAnimated + 2, y + effectiveH + kelpLength*0.7, kxAnimated + Math.sin(frameCount*0.03 + strand.phase*2)*3, y + effectiveH + kelpLength);
                            ctx.stroke();
                        }
                    }
                    break;
                case 'sunken_driftwood': /* ... (driftwood drawing, already stable) ... */ drawPlatformCeiling_Base(effectiveX,y,effectiveW,effectiveH, platform.color1 || '#8D6E63', platform.color2 || '#5D4037', PLATFORM_CORNER_RADIUS*0.5); if (effectiveH > 5 && effectiveW > 10 && visualDetails) { ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1; visualDetails.grains.forEach(grain => { ctx.beginPath(); ctx.moveTo(effectiveX, y + grain.startY * effectiveH); ctx.bezierCurveTo(effectiveX+effectiveW*0.3, y + grain.startY * effectiveH + grain.c1y, effectiveX+effectiveW*0.7, y + grain.startY * effectiveH + grain.c2y, effectiveX+effectiveW, y + grain.startY * effectiveH); ctx.stroke(); }); } break;
                case 'rusted_shipwreck_panel': /* ... (shipwreck drawing, already stable) ... */ drawPlatformCeiling_Base(effectiveX,y,effectiveW,effectiveH, platform.color1 || '#607D8B', platform.color2 || '#424242', 2); if (effectiveH > 8 && effectiveW > 20 && visualDetails) { ctx.fillStyle = 'rgba(0,0,0,0.4)'; visualDetails.rivets.forEach(rivet => { let rivetSize = rivet.s * (1-retractedPercent*0.7); if (rivetSize < 0.5) return; ctx.beginPath(); ctx.arc(effectiveX + rivet.x * effectiveW, y + rivet.y * effectiveH, rivetSize,0,Math.PI*2); ctx.fill(); }); } break;
                default: 
                    drawPlatformCeiling_Base(effectiveX,y,effectiveW,effectiveH, platform.color1, platform.color2, PLATFORM_CORNER_RADIUS);
            }

            if (effectiveH > 5) { /* ... (Functional overlay drawing logic remains largely the same) ... */ if (type === 'bouncy_vent') { ctx.fillStyle = 'rgba(200, 255, 230, 0.6)'; let ventY = y + effectiveH * 0.5; let ventSize = Math.min(effectiveW, effectiveH) * 0.4 * (1-retractedPercent*0.5); if (ventSize > 1) { ctx.beginPath(); ctx.ellipse(effectiveX + effectiveW/2, ventY, ventSize, ventSize*0.6, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.beginPath(); ctx.ellipse(effectiveX+effectiveW/2, ventY, ventSize*0.5, ventSize*0.3,0,0,Math.PI*2);ctx.fill(); } } else if (type === 'conveyor_current' && effectiveW > 20) { ctx.fillStyle = 'rgba(255, 255, 100, 0.7)'; let arrowSize = 10 * (1-retractedPercent*0.6); if (arrowSize > 2) { for (let i=0; i < effectiveW/30; i++) { ctx.beginPath(); let ax = effectiveX + 15 + i*30; if(ax > effectiveX + effectiveW - arrowSize - 5) continue; if (platform.direction > 0) { ctx.moveTo(ax - arrowSize, y + effectiveH/2 - arrowSize/2); ctx.lineTo(ax, y + effectiveH/2); ctx.lineTo(ax - arrowSize, y + effectiveH/2 + arrowSize/2); } else { ctx.moveTo(ax + arrowSize, y + effectiveH/2 - arrowSize/2); ctx.lineTo(ax, y + effectiveH/2); ctx.lineTo(ax + arrowSize, y + effectiveH/2 + arrowSize/2); } ctx.fill(); } } } if (platform.hasLurker) { const lurkerBaseSize = 15; let currentLurkerSize = lurkerBaseSize * (1 - retractedPercent * 0.8); if (currentLurkerSize > 2) { const lx = effectiveX + effectiveW / 2; const ly = y + effectiveH - currentLurkerSize / 2; ctx.fillStyle = platform.lurkerWarning ? '#FF6666' : '#B71C1C'; ctx.beginPath(); ctx.arc(lx, ly + currentLurkerSize*0.2, currentLurkerSize, Math.PI*0.2, Math.PI*0.8); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#FFE082'; ctx.beginPath(); ctx.arc(lx - currentLurkerSize*0.3, ly - currentLurkerSize*0.1, currentLurkerSize*0.2, 0, Math.PI*2); ctx.arc(lx + currentLurkerSize*0.3, ly - currentLurkerSize*0.1, currentLurkerSize*0.2, 0, Math.PI*2); ctx.fill(); if (platform.lurkerWarning) { ctx.fillStyle = 'rgba(255, 100, 100, 0.3)'; ctx.beginPath(); ctx.arc(lx, ly, currentLurkerSize * (1.2 + Math.sin(frameCount * 0.2) * 0.3), 0, Math.PI*2); ctx.fill(); } } } }
            ctx.restore();
        }
        function drawPlatformCeiling_Base(x,y,w,h,c1,c2,cornerRadius){ /* ... (original base draw) ... */ if (w < 1 || h < 1) return; ctx.beginPath(); const grad=ctx.createRadialGradient(x+w/2,y+h/2,0,x+w/2,y+h/2,Math.max(w,h)*0.7); grad.addColorStop(0,c1);grad.addColorStop(1,c2);ctx.fillStyle=grad; if(typeof ctx.roundRect==='function'){ctx.roundRect(x,y,w,h,[cornerRadius]);ctx.fill();ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=2;ctx.stroke();} else{ctx.fillRect(x,y,w,h);ctx.strokeRect(x,y,w,h);} }
        function generatePlatformVisualDetails(platform) { /* ... (visual detail generation, already stable) ... */ platform.visualDetails = {}; const { width, height, visualTheme } = platform; const c1 = platform.color1 || '#FF8A65'; const c2 = platform.color2 || '#D84315'; switch(visualTheme) { case 'rock_formation': platform.visualDetails.cracks = []; for(let i=0; i < 2 + width/60; i++){ platform.visualDetails.cracks.push({ x1: Math.random(), y1: Math.random(), x2: Math.random(), y2: Math.random() }); } break; case 'ancient_coral_shelf': platform.visualDetails.bumps = []; for(let i=0; i < 3 + width/40; i++){ platform.visualDetails.bumps.push({ c: Math.random() < 0.5 ? c1 : c2, r: (2 + Math.random()*4), x: Math.random(), yAnchor: 0.1 + Math.random() * 0.8 }); } break; case 'dense_kelp_bed': platform.visualDetails.kelpStrands = []; for (let i = 0; i < Math.ceil(width / 12) + 1; i++) { platform.visualDetails.kelpStrands.push({ startXOffset: (5 + i * 12) / width, phase: i, baseLength: 30 + Math.random()*10 }); } break; case 'sunken_driftwood': platform.visualDetails.grains = []; for(let i=0; i < height/4; i++){ platform.visualDetails.grains.push({ startY: (i*4+2)/height, c1y: (Math.random()-0.5)*4, c2y: (Math.random()-0.5)*4 }); } break; case 'rusted_shipwreck_panel': platform.visualDetails.rivets = []; for(let i=0; i < width/25; i++){ platform.visualDetails.rivets.push({ x: (5+i*25)/width, y: (height-5)/height, s:2 }); platform.visualDetails.rivets.push({ x: (5+i*25)/width, y: 5/height, s:2 }); } break; } }

        function drawGem(x,y,r,s=1){ /* ... (original gem draw) ... */ drawCircleWithGradient(x,y,r,'rgba(100,220,255,0.95)','rgba(50,150,200,0.75)',s);ctx.fillStyle='rgba(220,255,255,0.85)';ctx.beginPath();ctx.arc(x-r*0.3*s,y-r*0.3*s,r*0.25*s,0,Math.PI*2);ctx.fill();}
        
        // MODIFIED: drawAnglerFish to include rotation
        function drawAnglerFish(enemy){ // Pass whole enemy object
            const {x,y,size,color1,color2, angle} = enemy;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // Draw relative to (0,0) now
            drawCircleWithGradient(0,0,size,color1,color2);
            ctx.fillStyle=color2;
            for(let i=0;i<8;i++){
                const ang=(i/8)*Math.PI*2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(ang)*size*0.8, Math.sin(ang)*size*0.8);
                ctx.lineTo(Math.cos(ang+0.1)*size*1.25, Math.sin(ang+0.1)*size*1.25);
                ctx.lineTo(Math.cos(ang-0.1)*size*1.25, Math.sin(ang-0.1)*size*1.25);
                ctx.closePath();ctx.fill();
            }
            ctx.fillStyle='white';ctx.beginPath();ctx.arc(size*0.3,-size*0.2,size*0.25,0,Math.PI*2);ctx.fill();
            ctx.fillStyle='black';ctx.beginPath();ctx.arc(size*0.35,-size*0.2,size*0.12,0,Math.PI*2);ctx.fill();
            // Lure should "dangle" correctly relative to body
            const lureOffsetX = size * 0.7;
            const lureOffsetY = -size * 0.7;
            ctx.strokeStyle = 'rgba(200,200,150,0.8)'; ctx.lineWidth = size*0.1; ctx.beginPath(); ctx.moveTo(size*0.4, -size*0.3); ctx.lineTo(lureOffsetX, lureOffsetY); ctx.stroke();
            ctx.fillStyle='yellow';ctx.beginPath();ctx.arc(lureOffsetX,lureOffsetY,size*0.15,0,Math.PI*2);ctx.fill();
            
            ctx.restore();
        }

        function generateBackgroundColors(){ /* ... (original background gen) ... */ let hTop,sTop,lTop,hMid,sMid,lMid,hBot,sBot,lBot; const L=(internalLevel-1); const brightnessTier=Math.floor(L/3); const hueCycleInTier=L%3; const isDarkZone = (internalLevel > 2 && internalLevel % 4 === 0 && internalLevel > 0); let baseLightnessDarkest= isDarkZone ? 2 : (5+brightnessTier*7); baseLightnessDarkest=Math.min(baseLightnessDarkest,45); let gradientSpan=Math.max(10,30-brightnessTier*3); if (isDarkZone) gradientSpan = Math.max(5, 15 - brightnessTier * 2); let currentSaturation=Math.max(30,90-(currentDepth/STARTING_DEPTH)*70-brightnessTier*4); if (isDarkZone) currentSaturation = Math.max(10, 40 - (currentDepth/STARTING_DEPTH)*30 - brightnessTier*2); if(internalLevel===1 && !isDarkZone){ gradientBaseHue=220; hBot=gradientBaseHue;sBot=0;lBot=0; hTop=(hBot+10)%360; sTop=Math.max(10,currentSaturation-20); lTop=Math.min(20,lBot+gradientSpan); } else { let prevDarkestHue=gradientBaseHue; hBot=(prevDarkestHue+Math.random()*30-15+360)%360; sBot=currentSaturation; lBot=baseLightnessDarkest; hTop=(hBot+10+Math.random()*10+360)%360; sTop=Math.max(10,currentSaturation-15); lTop=Math.min(isDarkZone ? 30 : 80,lBot+gradientSpan); gradientBaseHue=hBot; } if(hueCycleInTier===1){ hTop=(hTop+120)%360; hBot=(hBot+120)%360; } else if(hueCycleInTier===2){ hTop=(hTop+240)%360; hBot=(hBot+240)%360; } hMid=(hTop+hBot)/2; if(Math.abs(hTop-hBot)>180)hMid=(hMid+180)%360; sMid=(sTop+sBot)/2; lMid=(lTop+lBot)/2; currentGradientColors=[`hsl(${hTop},${sTop}%,${lTop}%)`,`hsl(${hMid},${sMid}%,${lMid}%)`,`hsl(${hBot},${sBot}%,${lBot}%)`]; }
        function setupLevelBackgroundEffects() { /* ... (original setupLevelBackgroundEffects code) ... */ ambientBubbles = []; foregroundBubbles = []; const numAmbientBubbles = 35 + Math.floor(internalLevel * 2.5); for (let i = 0; i < numAmbientBubbles; i++) { ambientBubbles.push(new AmbientBubble(Math.random() < 0.7, 'ambient')); } const numFgBubbles = 7 + Math.floor(internalLevel * 0.3); for (let i = 0; i < numFgBubbles; i++) { foregroundBubbles.push(new AmbientBubble(true, 'foreground')); } }
        function checkAllOrbsCollected(){ /* ... (original checkAllOrbsCollected, calls generatePlatformVisualDetails for exit) ... */ if(stars.every(s=>s.collected)){if(!exitPlatform&&stars.length>0){exitPlatform={x:TARGET_CANVAS_WIDTH/2-60,y:EXIT_CEILING_UNDERSIDE_Y-EXIT_CEILING_HEIGHT,width:120,height:EXIT_CEILING_HEIGHT,visualTheme: 'rock_formation', color1:'#607D8B',color2:'#455A64',static:true,type:'exit_portal_ceiling',active:true}; generatePlatformVisualDetails(exitPlatform);}}}
        function initLevel(isFullReset = false) { /* ... (initLevel already updated for visual themes and calls generatePlatformVisualDetails) ... */ platforms=[];enemies=[];stars=[];powerUps=[];gameEffectParticles=[];exitPlatform=null;seaFloorDecorations=[]; strongCurrents = []; if(isFullReset){ internalLevel=1;currentDepth=STARTING_DEPTH;airCollected=0;player.lives=3;gradientBaseHue=200; player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL; platformBaseSpeed = 0.42 * gameSpeedFactor; } generateBackgroundColors();setupLevelBackgroundEffects(); const startCeilingH=20;const startCeilingTopY=TARGET_CANVAS_HEIGHT-150; platforms.push({x:TARGET_CANVAS_WIDTH/2-70,y:startCeilingTopY,width:140,height:startCeilingH,visualTheme: 'rock_formation', color1:'#546E7A',color2:'#37474F',static:false,type:'start_ceiling',active:true,direction:1,speed:platformBaseSpeed*0.6}); generatePlatformVisualDetails(platforms[0]); player.x=platforms[0].x+platforms[0].width/2;player.y=platforms[0].y+platforms[0].height+player.radius+40;player.vx=0;player.vy=0;player.isAttached=false;player.attachedPlatform=null;player.canTakeDamage=true;clearTimeout(player.damageCooldownTimeout);player.invincible=false;player.invincibleTimer=0;player.speedBoost=false;player.speedBoostTimer=0;player.temporaryDragTimer=0; player.sonarPulseActive=false; player.sonarPulseTimer=0; let currentCeilingUndersideY=platforms[0].y+platforms[0].height; const highestPossibleCeilingTopY=TOP_SURFACE_DEATH_Y+player.radius+EXIT_CEILING_HEIGHT+20; let numDynamicCeilings=3+Math.floor(internalLevel*1.1); const availableVSpace=currentCeilingUndersideY-highestPossibleCeilingTopY; let dynamicMaxFloat = (player.currentPushForce * player.currentPushForce) / (2*Math.abs(BUOYANCY)); dynamicMaxFloat = Math.max(dynamicMaxFloat, player.radius * 3 + 20); let minGapForGen = dynamicMaxFloat * MIN_CEILING_UNDERSIDE_GAP_FACTOR; if(availableVSpace > 0){ numDynamicCeilings = Math.min(numDynamicCeilings, Math.floor(availableVSpace / (minGapForGen + startCeilingH))); } else { numDynamicCeilings = 0; } numDynamicCeilings = Math.max(numDynamicCeilings, internalLevel === 1 ? 1 : 2); let dynamicCeilingCfgs = []; let specialCeilingsToGen = []; let specialPlatformBudget = 0; if (internalLevel >= 2) specialPlatformBudget = 1; if (internalLevel >= 3) specialPlatformBudget = 1 + Math.floor((internalLevel-3)/2.2); for(let k = 0; k < specialPlatformBudget; k++) { let availableSpecials = SPECIAL_PLATFORM_TYPES.slice(); if (internalLevel < 3) { availableSpecials = availableSpecials.filter(type => type === 'disappearing_coral' || type === 'bouncy_vent' || type === 'conveyor_current'); } else if (internalLevel < 4) { availableSpecials = availableSpecials.filter(type => type !== 'slippery_kelp_patch'); } if (availableSpecials.length > 0) { specialCeilingsToGen.push(availableSpecials[Math.floor(Math.random() * availableSpecials.length)]); } } for(let i = 0; i < numDynamicCeilings; i++){ let platW = 180 - internalLevel * 7; platW = Math.max(70, platW) + Math.random() * (internalLevel < 5 ? 35 : 10); const platH = 20; let platX = Math.random() * (TARGET_CANVAS_WIDTH - platW); dynamicMaxFloat = (player.currentPushForce * player.currentPushForce) / (2*Math.abs(BUOYANCY)); dynamicMaxFloat = Math.max(dynamicMaxFloat, player.radius * 3 + 20); let currentMinGap = dynamicMaxFloat * MIN_CEILING_UNDERSIDE_GAP_FACTOR; let currentMaxGap = dynamicMaxFloat * MAX_CEILING_UNDERSIDE_GAP_FACTOR; let newCeilingUndersideY_max = currentCeilingUndersideY - currentMinGap; let newCeilingUndersideY_min = currentCeilingUndersideY - currentMaxGap; newCeilingUndersideY_min = Math.max(newCeilingUndersideY_min, highestPossibleCeilingTopY + platH); if(newCeilingUndersideY_min >= newCeilingUndersideY_max - platH / 1.5){ if (i < (internalLevel === 1 ? 1 : 2)) { newCeilingUndersideY_min = newCeilingUndersideY_max - platH / 1.5 -1; } else break; } let y_under = Math.random() * (newCeilingUndersideY_max - newCeilingUndersideY_min) + newCeilingUndersideY_min; let y_top = y_under - platH; let currentType='normal_ceiling';let pC1='#607D8B',pC2='#455A64'; let platSpd = platformBaseSpeed * (0.4 + internalLevel*0.07 + Math.random()*0.45); platSpd = Math.min(platSpd, platformBaseSpeed * 3.5); platSpd = Math.max(platSpd, platformBaseSpeed * 0.3); let platDir=(Math.random()<0.5?1:-1);let isStat=false; let visual = PLATFORM_VISUAL_THEMES[Math.floor(Math.random() * PLATFORM_VISUAL_THEMES.length)]; let platformData={x:platX,y:y_top,width:platW,height:platH,visualTheme: visual, color1:pC1,color2:pC2,static:isStat,type:currentType,active:true,direction:platDir,speed:platSpd,originalColor1:pC1,timer:Math.floor(80/gameSpeedFactor),reappearTime: Math.floor(180/gameSpeedFactor), hasLurker: false, lurkerChargeTime: 0, lurkerWarned: false, lurkerMaxCharge: Math.floor(150 / gameSpeedFactor), isRetracted: false, retractTimer: 0, maxRetractTime: Math.floor(180/gameSpeedFactor), retractedPercent: 0 }; let willHaveEnemy = (enemies.filter(e => e.type !== 'jellyfish').length < Math.floor(internalLevel/1.8)+ (internalLevel > 2 ? 1:0) && Math.random() < 0.05 + internalLevel*0.08 && i > 0 && internalLevel > 1); if(willHaveEnemy && internalLevel<8) platformData.width = Math.max(platformData.width, 150); if(specialCeilingsToGen.length>0&&Math.random()<(0.18 + internalLevel*0.075)){ platformData.type=specialCeilingsToGen.shift(); switch(platformData.type){ case 'disappearing_coral': platformData.visualTheme = 'ancient_coral_shelf'; platformData.color1='#FFAB91';platformData.color2='#FF7043';platformData.static=true; platformData.reappearTime = Math.floor(360 / gameSpeedFactor); break; case 'bouncy_vent': platformData.visualTheme = 'rock_formation'; platformData.color1='#80CBC4';platformData.color2='#26A69A';platformData.static=true;platformData.speed=0;break; case 'conveyor_current': platformData.visualTheme = 'rusted_shipwreck_panel'; platformData.color1='#E8D57D';platformData.color2='#D4B55A';platformData.static=false;platformData.speed*=1.3;break; case 'retracting_coral': platformData.visualTheme = 'ancient_coral_shelf'; platformData.color1='#EF9A9A'; platformData.color2='#C62828'; platformData.static=true; platformData.maxRetractTime = Math.floor((150 + Math.random()*60)/gameSpeedFactor); break; case 'slippery_kelp_patch': platformData.visualTheme = 'dense_kelp_bed'; platformData.static = Math.random() < 0.5; break; } } if (platformData.type === 'slippery_kelp_patch') platformData.visualTheme = 'dense_kelp_bed'; if (internalLevel >= 5 && platformData.type !== 'bouncy_vent' && platformData.type !== 'disappearing_coral' && platformData.type !== 'retracting_coral' && platformData.width > 100 && Math.random() < 0.1 + (internalLevel - 5) * 0.03) { platformData.hasLurker = true; willHaveEnemy = false; } generatePlatformVisualDetails(platformData); dynamicCeilingCfgs.push(platformData); if(willHaveEnemy && platformData.type !=='disappearing_coral' && platformData.type !=='bouncy_vent' && !platformData.hasLurker){ enemies.push({x:platformData.x+platformData.width/2,y:platformData.y+platformData.height+20,size:16,platformAttached:platformData,direction:Math.random()>0.5?1:-1,speed:platformBaseSpeed*(0.3+internalLevel*0.04+Math.random()*0.3),color1:'#FF6F00',color2:'#E65100', type:'angler', angle: Math.random() * Math.PI * 2 }); } currentCeilingUndersideY=y_under; } dynamicCeilingCfgs.sort((a,b)=>b.y-a.y);platforms.splice(1,0,...dynamicCeilingCfgs); if(internalLevel===1){platforms.push({x:0,y:TARGET_CANVAS_HEIGHT-BOTTOM_DEATH_FLOOR_HEIGHT,width:TARGET_CANVAS_WIDTH,height:BOTTOM_DEATH_FLOOR_HEIGHT,visualTheme:'rock_formation', color1:'#3E2723',color2:'#201512',static:true,deadly:true,type:'ocean_floor',active:true}); generatePlatformVisualDetails(platforms[platforms.length-1]);} stars=[]; const gemR=11;const numGems=Math.max(2,Math.floor(platforms.filter(p=>p.type!=='start_ceiling'&&p.type!=='ocean_floor').length/1.8)+Math.floor(internalLevel/1.2));for(let i=0;i<numGems;i++){let v=false;let gX,gY;let att=0;while(!v&&att<50){att++;const cPs=platforms.filter(p=>p.type!=='start_ceiling'&&p.type!=='ocean_floor'&&!p.deadly && p.active);if(cPs.length===0)break;const bC=cPs[Math.floor(Math.random()*cPs.length)];gX=bC.x+Math.random()*bC.width;gY=bC.y+bC.height+gemR+(15+Math.random()*35);const floorBoundary=(internalLevel===1?(TARGET_CANVAS_HEIGHT-BOTTOM_DEATH_FLOOR_HEIGHT):TARGET_CANVAS_HEIGHT);gY=Math.min(gY,floorBoundary-gemR-10);v=true;for(const pl of platforms){if(gX+gemR>pl.x&&gX-gemR<pl.x+pl.width&&gY+gemR>pl.y&&gY-gemR<pl.y+pl.height){v=false;break;}}if(!v)continue;for(const oG of stars){const dx=gX-oG.x;const dy=gY-oG.y;if(Math.sqrt(dx*dx+dy*dy)<gemR*3.5){v=false;break;}}}if(v){stars.push({x:gX,y:gY,radius:gemR,scale:1,collected:false,bobOffset:Math.random()*Math.PI*2,bobSpeed:0.025+Math.random()*0.02});}} if (internalLevel >= 2) { let powerUpChance = 0.20 + (internalLevel-2) * 0.05; if (Math.random() < powerUpChance) { let puX, puY, validPosition = false, attempts = 0; const puRadius = 14; while(!validPosition && attempts < 20) { attempts++; const platformCandidates = platforms.filter(p => p.type !== 'start_ceiling' && p.type !== 'ocean_floor' && !p.deadly && p.active); if (platformCandidates.length > 0) { const basePlatform = platformCandidates[Math.floor(Math.random() * platformCandidates.length)]; puX = basePlatform.x + Math.random() * basePlatform.width; puY = basePlatform.y + basePlatform.height + puRadius + (15 + Math.random() * 20); const floorBoundary = (internalLevel === 1 ? (TARGET_CANVAS_HEIGHT - BOTTOM_DEATH_FLOOR_HEIGHT) : TARGET_CANVAS_HEIGHT); puY = Math.min(puY, floorBoundary - puRadius - 10); validPosition = true; for (const pl of platforms) { if (puX + puRadius > pl.x && puX - puRadius < pl.x + pl.width && puY + puRadius > pl.y && puY - puRadius < pl.y + pl.height) { validPosition = false; break; } } if (validPosition) { for (const s of stars) { const dx = puX - s.x; const dy = puY - (s.y + Math.sin(s.bobOffset+frameCount*s.bobSpeed)*3); if (Math.sqrt(dx * dx + dy * dy) < puRadius + s.radius + 15) { validPosition = false; break; } } } if (validPosition) { for (const oPu of powerUps) { const dx = puX - oPu.x; const dy = puY - (oPu.y + Math.sin(oPu.animationTimer)*6); if (Math.sqrt(dx * dx + dy * dy) < puRadius * 3) { validPosition = false; break; } } } } else { break; }  } if (validPosition) { let puTypeRand = Math.random(); let puType; if (internalLevel >= 6 && puTypeRand < 0.25) puType = 'extra_life'; else if (internalLevel >= 4 && puTypeRand < 0.5) puType = 'sonar_pulse'; else if (puTypeRand < 0.75) puType = 'shield_bubble'; else puType = 'propulsion_boost'; powerUps.push(new PowerUp(puX, puY, puType)); } } } if (internalLevel >= 3) { const numJellies = Math.floor((internalLevel - 2) / 2) + (Math.random() < 0.3 ? 1 : 0); for (let i = 0; i < numJellies; i++) { enemies.push(new AbyssalJellyfish(Math.random() * TARGET_CANVAS_WIDTH, Math.random() * TARGET_CANVAS_HEIGHT * 0.8)); } } if (internalLevel >= 5 && Math.random() < 0.3 + (internalLevel - 5) * 0.05) { const currentY = Math.random() * (TARGET_CANVAS_HEIGHT * 0.6) + TARGET_CANVAS_HEIGHT * 0.1; const currentHeight = 80 + Math.random() * 70; const currentStrength = (Math.random() < 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.3 + internalLevel * 0.03); strongCurrents.push(new StrongCurrent(currentY, currentHeight, currentStrength)); } checkAllOrbsCollected(); }
        function update(){ /* ... (original update game states) ... */ if(justRestartedFromGameOver && !keys[' ']){ justRestartedFromGameOver = false; } switch(gameState){ case 'start': if(keys[' ']){ playerCanMove=true; gameState='playing'; keys[' ']=false; updateUIVisibility(); attemptPlayMusic(); } break; case 'playing': if(keys['p']||keys['Escape']){ gameState='paused'; keys['p']=false; keys['Escape']=false; if(abyssalDroneMusic) abyssalDroneMusic.pause(); if(cyclingPlatformsMusic) cyclingPlatformsMusic.pause(); playerCanMove=false; updateUIVisibility(); } updatePlayer(); updatePlatforms(); updateEnemies(); updateStars(); updatePowerUps(); updateGameEffectParticles(); updateAmbientBubbles(); checkExitPlatform(); strongCurrents.forEach(c => c.update()); break; case 'paused': break; case 'transitioning': transitionAlpha+=transitionSpeed; if(transitionAlpha>=1){ transitionAlpha=1; if(transitionCallback) transitionCallback(); transitionSpeed*=-1; } else if(transitionAlpha<=0){ transitionAlpha=0; transitionSpeed=Math.abs(transitionSpeed); gameState=(transitionCallback&&typeof transitionCallback.toString==='function'&&transitionCallback.toString().includes("gameState='gameOver'"))?'gameOver':(transitionCallback&&typeof transitionCallback.toString==='function'&&transitionCallback.toString().includes("gameState='gameWon'"))?'gameWon':'playing'; playerCanMove = gameState === 'playing'; updateUIVisibility(); } break; case 'gameOver': if ((keys[' '] || keys['p'] || keys['Escape']) && !justRestartedFromGameOver) { attemptPlayMusic(); resetGame(true); if (keys[' ']) keys[' '] = false; if (keys['p']) keys['p'] = false; if (keys['Escape']) keys['Escape'] = false; justRestartedFromGameOver = true; } break; case 'gameWon': if ((keys[' '] || keys['p'] || keys['Escape']) && !justRestartedFromGameOver) { attemptPlayMusic(); resetGame(true); if (keys[' ']) keys[' '] = false; if (keys['p']) keys['p'] = false; if (keys['Escape']) keys['Escape'] = false; justRestartedFromGameOver = true; } break; } }
        function updatePlayer() { /* ... (Player update, already includes no death at bottom) ... */ if (!playerCanMove) { player.vx = 0; return; } player.currentPushForce = PLAYER_BASE_PUSH_INITIAL - (player.radius - player.baseRadius) * 0.30; player.currentPushForce = Math.max(player.currentPushForce, PLAYER_BASE_PUSH_INITIAL * 0.25); let currentSpeed = player.baseSpeed; if (player.speedBoost) { currentSpeed *= 1.7; player.speedBoostTimer--; if (player.speedBoostTimer <= 0) player.speedBoost = false; } let currentHorizontalResistance = WATER_RESISTANCE_H_NORMAL; if (player.isAttached && player.attachedPlatform && player.attachedPlatform.type === 'slippery_kelp_patch') { currentHorizontalResistance = WATER_RESISTANCE_H_SLIPPERY; } if (keys.ArrowLeft) player.vx = Math.max(player.vx - (0.3 * gameSpeedFactor), -currentSpeed); else if (keys.ArrowRight) player.vx = Math.min(player.vx + (0.3 * gameSpeedFactor), currentSpeed); else player.vx *= currentHorizontalResistance; player.x += player.vx; if (keys[' ']) { if (player.isAttached) { player.vy = player.currentPushForce; if (player.attachedPlatform.type === 'retracting_coral' && !player.attachedPlatform.isRetracted) { player.attachedPlatform.isRetracted = true; player.attachedPlatform.active = false; player.attachedPlatform.retractTimer = player.attachedPlatform.maxRetractTime; playRetractPlatformSound(); } player.isAttached = false; player.attachedPlatform = null; playPushFromCeilingSound(); } else { let canQuickPush = false; let quickPushTargetPlatform = null; for (const plat of platforms.concat(exitPlatform ? [exitPlatform] : [])) { if (!plat || !plat.active || plat.deadly || plat.type === 'ocean_floor') continue; const playerTop = player.y - player.radius; const platformUnderside = plat.y + plat.height; if (player.x + player.radius * 0.6 > plat.x && player.x - player.radius * 0.6 < plat.x + plat.width) { if (playerTop < platformUnderside + (5 * gameSpeedFactor) && playerTop > platformUnderside - (35 * gameSpeedFactor) && player.vy <= (0.5 * gameSpeedFactor)) { canQuickPush = true; quickPushTargetPlatform = plat; break; } } } if (canQuickPush) { player.vy = player.currentPushForce * 0.8; playPushFromCeilingSound(); if (quickPushTargetPlatform && quickPushTargetPlatform.type === 'conveyor_current') { player.vx -= quickPushTargetPlatform.direction * quickPushTargetPlatform.speed * 0.3; } if (quickPushTargetPlatform && quickPushTargetPlatform.type === 'retracting_coral' && !quickPushTargetPlatform.isRetracted) { quickPushTargetPlatform.isRetracted = true; quickPushTargetPlatform.active = false; quickPushTargetPlatform.retractTimer = quickPushTargetPlatform.maxRetractTime; playRetractPlatformSound(); } } for (const enemy of enemies) { if (enemy.type === 'jellyfish') { const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dist = Math.sqrt(dx*dx + dy*dy); const pushRadius = player.radius + 60; if (dist < pushRadius && dist > 0) { const pushStrength = 8 * gameSpeedFactor; enemy.pushForceX = (dx / dist) * pushStrength; enemy.pushForceY = (dy / dist) * pushStrength; enemy.pushedTimer = Math.floor(15 / gameSpeedFactor); enemy.speedX = 0; enemy.speedY = 0; playJellyfishPushedSound(); } } } } keys[' '] = false; } if (!player.isAttached) { player.vy += BUOYANCY; if (player.temporaryDragTimer > 0) { player.vy += player.temporaryDragForce; player.temporaryDragTimer--; } const PULL_UP_FORCE = PLATFORM_ATTACH_PULL_UP; const PULL_UP_RANGE = 30 * gameSpeedFactor; const JUST_PAST_OFFSET = 2 * gameSpeedFactor; const SNAP_TOLERANCE = 2.0 * gameSpeedFactor; for (const platform of platforms.concat(exitPlatform ? [exitPlatform] : [])) { if (!platform || !platform.active || platform.deadly || platform.type === 'ocean_floor') continue; const playerTopY = player.y - player.radius; const platformBottomY = platform.y + platform.height; const prevFrameVy = (player.vy - BUOYANCY) / WATER_RESISTANCE_V; const prevPlayerActualY = player.y - prevFrameVy ; const prevPlayerTopY = prevPlayerActualY - player.radius; if (player.x + player.radius * 0.8 > platform.x && player.x - player.radius * 0.8 < platform.x + platform.width) { if (player.vy <= 0.1 * gameSpeedFactor) { if (playerTopY > platformBottomY - PULL_UP_RANGE && playerTopY < platformBottomY + JUST_PAST_OFFSET) { player.vy += PULL_UP_FORCE; } if (playerTopY <= platformBottomY + JUST_PAST_OFFSET && prevPlayerTopY > platformBottomY - SNAP_TOLERANCE) { player.y = platformBottomY + player.radius; player.vy = 0; player.isAttached = true; player.attachedPlatform = platform; playAttachToCeilingSound(); if (platform.type === 'bouncy_vent') { player.vy = player.currentPushForce * 1.7; player.isAttached = false; player.attachedPlatform = null; playBouncyVentSound(); } else if (platform.type === 'exit_portal_ceiling') { checkExitPlatform(); } break; } } } } } player.vy *= WATER_RESISTANCE_V; player.y += player.vy; for (const current of strongCurrents) { if (player.y + player.radius > current.y && player.y - player.radius < current.y + current.height) { player.x += current.strength; } } if (player.x < player.radius) { player.x = player.radius; player.vx *= -0.3; } if (player.x > TARGET_CANVAS_WIDTH - player.radius) { player.x = TARGET_CANVAS_WIDTH - player.radius; player.vx *= -0.3; } if (player.y - player.radius < TOP_SURFACE_DEATH_Y && !player.invincible && player.canTakeDamage) { playerDie("surfaced_abyss"); } const deadlyFloor = platforms.find(p => p.type === 'ocean_floor'); if (internalLevel === 1 && deadlyFloor && player.y + player.radius > deadlyFloor.y) { player.y = deadlyFloor.y - player.radius; if (player.vy > 0) { player.vy = 0; } } else if (player.y + player.radius > TARGET_CANVAS_HEIGHT) { player.y = TARGET_CANVAS_HEIGHT - player.radius; if (player.vy > 0) { player.vy = 0;} } if (player.isAttached && player.attachedPlatform) { const p = player.attachedPlatform; if (!p.active) { player.isAttached = false; player.attachedPlatform = null; } else { let stillHorizontallyOn = (player.x + player.radius * 0.7 > p.x && player.x - player.radius * 0.7 < p.x + p.width); if (p.type === 'conveyor_current') { player.x += p.direction * p.speed * 1.7; if ((p.direction > 0 && player.x + player.radius * 0.3 >= p.x + p.width ) || (p.direction < 0 && player.x - player.radius * 0.3 <= p.x )) { player.isAttached = false; player.vx += p.direction * p.speed * 1.0; stillHorizontallyOn = false; } } else if (!p.static) { player.x += p.direction * p.speed; } if (player.isAttached && stillHorizontallyOn) { player.y = p.y + p.height + player.radius; } else if (player.isAttached) { player.isAttached = false; } if (!player.isAttached) { player.attachedPlatform = null; } if (player.isAttached && p.hasLurker) { p.lurkerChargeTime++; if (!p.lurkerWarned && p.lurkerChargeTime > p.lurkerMaxCharge * 0.6) { p.lurkerWarned = true; playLurkerWarningSound(); } if (p.lurkerChargeTime >= p.lurkerMaxCharge) { if (!player.invincible && player.canTakeDamage) { playerDie("lurker_bite"); playLurkerBiteSound(); player.vy = (BUOYANCY > 0 ? 1.5 : -1.5) * 1.5 * gameSpeedFactor; } p.lurkerChargeTime = 0; p.lurkerWarned = false; } } else if (p.hasLurker) { p.lurkerChargeTime = 0; p.lurkerWarned = false; } } } if (player.invincibleTimer > 0) { player.invincibleTimer--; if (player.invincibleTimer <= 0) { player.invincible = false; player.canTakeDamage = true; clearTimeout(player.damageCooldownTimeout); } } if (player.sonarPulseActive) { player.sonarPulseTimer--; player.sonarPulseRadius += (player.sonarPulseMaxRadius / (Math.floor(180 / gameSpeedFactor) / 3)); if (player.sonarPulseTimer % Math.floor(60 / gameSpeedFactor) === 0 && player.sonarPulseCount > 0) { playSonarPulseFireSound(); enemies.forEach(enemy => { if (enemy.type === 'angler' || enemy.type === 'jellyfish') { const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist < player.sonarPulseRadius && dist > 0) { const pushForce = 5 * gameSpeedFactor; enemy.speedX = (dx / dist) * pushForce; enemy.speedY = (dy / dist) * pushForce; if(enemy.pushedBySonarTimer === undefined) enemy.pushedBySonarTimer = 0; enemy.pushedBySonarTimer = Math.floor(30 / gameSpeedFactor); } } }); player.sonarPulseCount--; } if (player.sonarPulseTimer <= 0 || player.sonarPulseCount <= 0) { player.sonarPulseActive = false; player.sonarPulseRadius = 0; } } for (let i = stars.length - 1; i >= 0; i--) { const gem = stars[i]; if (!gem.collected) { const dx = player.x - gem.x; const dy = player.y - (gem.y + Math.sin(gem.bobOffset + frameCount * gem.bobSpeed) * 3); if (Math.sqrt(dx * dx + dy * dy) < player.radius + gem.radius) { gem.collected = true; airCollected += 20; player.radius = Math.min(player.maxRadius, player.radius + player.radiusGrowthPerStar); playGemSound(); checkAllOrbsCollected(); } } } for (let i = powerUps.length - 1; i >= 0; i--) { const pu = powerUps[i]; if (!pu.collected) { const puDrawY = pu.y + Math.sin(pu.animationTimer) * 6; const dx = player.x - pu.x; const dy = player.y - puDrawY; if (Math.sqrt(dx * dx + dy * dy) < player.radius + pu.radius) { pu.collected = true; playPowerUpSound(pu.type); if (pu.type === 'shield_bubble') { player.invincible = true; player.invincibleTimer = Math.floor(300 / gameSpeedFactor); } else if (pu.type === 'propulsion_boost') { player.speedBoost = true; player.speedBoostTimer = Math.floor(300 / gameSpeedFactor); } else if (pu.type === 'extra_life') { player.lives++; } else if (pu.type === 'sonar_pulse') { player.sonarPulseActive = true; player.sonarPulseTimer = Math.floor(180 / gameSpeedFactor); player.sonarPulseRadius = player.radius + 10; player.sonarPulseCount = 3; } powerUps.splice(i, 1); } } } 
            // MODIFIED: Jellyfish upward nudge on collision
            for (const enemy of enemies) { 
                if (enemy.type === 'jellyfish') { 
                    const enemyDrawY = enemy.y + Math.sin(enemy.bobOffset * 1.5) * 4;
                    const dx = player.x - enemy.x; const dy = player.y - enemyDrawY; 
                    const dist = Math.sqrt(dx*dx + dy*dy); 
                    if (dist < player.radius + enemy.radius * 0.7) { 
                        if (!player.invincible && player.canTakeDamage && player.temporaryDragTimer <=0 && enemy.pushedTimer <=0) { 
                            if (player.vy < -0.5 * gameSpeedFactor && (player.y - player.radius) > (enemyDrawY + enemy.radius * 0.2) ) { 
                                player.vy *= -0.4; player.y = enemyDrawY + enemy.radius + player.radius + 2; playJellyfishBounceSound(); 
                                enemy.speedY = Math.min(enemy.speedY - 0.8 * gameSpeedFactor, -0.2 * gameSpeedFactor); // Stronger upward nudge
                            } else { 
                                player.temporaryDragForce = 0.3 * gameSpeedFactor; player.temporaryDragTimer = Math.floor(60 / gameSpeedFactor); playJellyfishZapSound(); 
                                // Nudge jellyfish UP and slightly away from player
                                enemy.speedY = Math.min(enemy.speedY - 0.5 * gameSpeedFactor, -0.1 * gameSpeedFactor); 
                                enemy.speedX += (enemy.x > player.x ? 0.2 : -0.2) * gameSpeedFactor;
                            } 
                        } 
                    } 
                } else if (enemy.type === 'angler'){ const dx = player.x - enemy.x; const dy = player.y - enemy.y; if (Math.sqrt(dx * dx + dy * dy) < player.radius + enemy.size * 0.7 && !player.invincible && player.canTakeDamage) { playerDie("hit_enemy"); player.vy = (BUOYANCY > 0 ? 1.5 : -1.5) * 2 * gameSpeedFactor; player.vx = (dx > 0 ? 4 : -4) * gameSpeedFactor; } } 
            }
            updateUI();
        }

        // MODIFIED: updateEnemies to include anglerfish rotation
        function updateEnemies(){ 
            for(let i = enemies.length - 1; i >= 0; i--) { 
                const enemy = enemies[i]; 
                if (enemy.type === 'angler') { 
                    if(!enemy.platformAttached||!enemy.platformAttached.active){enemy.speed*=0.95; enemy.y += BUOYANCY*0.5; if(enemy.y < -enemy.size*2) enemies.splice(i,1); continue;} 
                    const pa=enemy.platformAttached;enemy.x+=enemy.direction*enemy.speed;const patrolMargin=5;if(enemy.x-enemy.size<pa.x+patrolMargin||enemy.x+enemy.size>pa.x+pa.width-patrolMargin){enemy.direction*=-1;enemy.x=Math.max(pa.x+patrolMargin+enemy.size,Math.min(enemy.x,pa.x+pa.width-patrolMargin-enemy.size));}enemy.y=pa.y+pa.height+enemy.size+5;
                    enemy.angle += 0.008 * gameSpeedFactor * enemy.direction; // Rotate based on patrol direction
                } else if (enemy.type === 'jellyfish') { 
                    enemy.update(); 
                } 
                if (enemy.pushedBySonarTimer && enemy.pushedBySonarTimer > 0) { enemy.x += enemy.speedX; enemy.y += enemy.speedY; enemy.speedX *= 0.9; enemy.speedY *= 0.9; enemy.pushedBySonarTimer--; } 
            } 
        }
        function updatePlatforms(){ /* ... (platform update logic already includes retracting coral) ... */ for(let i=platforms.length-1; i>=0; i--){ const p=platforms[i]; if(!p.static&&!p.deadly&&p.type!=='ocean_floor'){ let oldDirection=p.direction;p.x+=p.direction*p.speed;if(p.x<=0||p.x+p.width>=TARGET_CANVAS_WIDTH){p.direction*=-1;p.x=Math.max(0,Math.min(p.x,TARGET_CANVAS_WIDTH-p.width));if(oldDirection!==p.direction){for(const enemy of enemies){if(enemy.platformAttached===p && enemy.type==='angler')enemy.direction=p.direction;}}}} if(p.type==='disappearing_coral'&&p.active){ if(player.isAttached&&player.attachedPlatform===p){p.timer--;}if(p.timer<=0){p.active=false;if(player.isAttached&&player.attachedPlatform===p){player.isAttached=false;player.attachedPlatform=null;player.vy=BUOYANCY*4;}setTimeout(()=>{p.active=true;p.originalColor1&&(p.color1=p.originalColor1);p.timer=Math.floor(80/gameSpeedFactor);},p.reappearTime);}} if (p.type === 'retracting_coral' && p.isRetracted) { p.retractTimer--; p.retractedPercent = 1 - (p.retractTimer / p.maxRetractTime); p.retractedPercent = Math.max(0, Math.min(1, p.retractedPercent)); if (p.retractTimer <= 0) { p.isRetracted = false; p.active = true; p.retractedPercent = 0; } } } }
        function updateStars(){ /* ... (original star update) ... */ stars.forEach(star=>{if(!star.collected){star.bobOffset+=star.bobSpeed;}})}
        function updatePowerUps(){ /* ... (original powerup update) ... */ powerUps.forEach(pu => { if(!pu.collected) pu.update();})} 
        function updateGameEffectParticles(){ /* ... (original particle update) ... */ for(let i=gameEffectParticles.length-1;i>=0;i--){gameEffectParticles[i].update();if(gameEffectParticles[i].lifetime<=0||gameEffectParticles[i].size<=0.1){gameEffectParticles.splice(i,1);}}}
        function updateAmbientBubbles(){ /* ... (original ambient bubble update) ... */ for(const b of ambientBubbles){ b.update(); } for(const b of foregroundBubbles){ b.update(); } }
        function playerDie(reason="unknown"){ /* ... (original playerDie, already robust) ... */ if(player.invincible && !reason.includes("surfaced") && reason !== "fell_off_bottom") return; if(!player.canTakeDamage && !player.invincible && !reason.includes("surfaced") && reason !== "fell_off_bottom") return; player.lives--; playLifeLostSound(); updateUI(); if(player.lives<=0){ gameOver=true; gameOverFinalAir=airCollected; if(airCollected>totalAirHighScore){totalAirHighScore=airCollected;localStorage.setItem('abyssalAscentTotalAir_v14',totalAirHighScore);} playerCanMove=false; gameState='transitioning'; transitionCallback=()=>{gameState='gameOver';playGameOverSound();updateUIVisibility();}; }else{ playerCanMove=false; gameState='transitioning'; transitionCallback=()=>{ if(platforms.length>0&&platforms[0].type==='start_ceiling'){ player.x=platforms[0].x+platforms[0].width/2; player.y=platforms[0].y+platforms[0].height+player.radius+40; player.isAttached=false;player.attachedPlatform=null; }else{ player.x=TARGET_CANVAS_WIDTH/2;player.y=TARGET_CANVAS_HEIGHT-100;player.isAttached=false; } player.vx=0;player.vy=0; player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL; player.invincible=true;player.invincibleTimer=Math.floor(120/gameSpeedFactor); player.temporaryDragTimer = 0; updateUIVisibility(); }; } }
        function checkExitPlatform(){ /* ... (original exit platform) ... */ if(exitPlatform&&player.isAttached&&player.attachedPlatform===exitPlatform){if(gameState==='playing'){airCollected+=100*internalLevel;currentDepth-=DEPTH_DECREASE_PER_LEVEL;if(currentDepth<=0){currentDepth=0;gameState='transitioning';playerCanMove=false;transitionCallback=()=>{gameState='gameWon';playGameWonSound();if(airCollected>totalAirHighScore){totalAirHighScore=airCollected;localStorage.setItem('abyssalAscentTotalAir_v14',totalAirHighScore);}updateUIVisibility();};return;}playLevelCompleteSound();playerCanMove=false;gameState='transitioning';transitionCallback=()=>{internalLevel++;platformBaseSpeed+=0.015 * gameSpeedFactor;player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL;initLevel();updateUIVisibility();};}}}
        function drawBackground(){ /* ... (original background draw) ... */ const grad=ctx.createLinearGradient(0,0,0,TARGET_CANVAS_HEIGHT);currentGradientColors.forEach((c,i)=>{grad.addColorStop(i/(currentGradientColors.length-1),c);});ctx.fillStyle=grad;ctx.fillRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT);}
        function drawGameElements(){ /* ... (drawGameElements already updated for new platform drawing) ... */ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} strongCurrents.forEach(c => c.draw(ctx)); for(const p of platforms){if(p.active || (p.type === 'retracting_coral' && p.isRetracted) ) drawPlatform(p); } if(exitPlatform){ drawPlatform(exitPlatform); ctx.fillStyle='white';ctx.strokeStyle='#104010';ctx.lineWidth=2;ctx.font='bold 14px Arial';ctx.textAlign='center'; ctx.strokeText('ASCENT',exitPlatform.x+exitPlatform.width/2,exitPlatform.y+exitPlatform.height/2+5); ctx.fillText('ASCENT',exitPlatform.x+exitPlatform.width/2,exitPlatform.y+exitPlatform.height/2+5); } if(internalLevel===1){for(const decor of seaFloorDecorations){ctx.fillStyle=decor.color;ctx.fillRect(decor.x-decor.w/2,decor.baseY-decor.h,decor.w,decor.h);}} for(const gem of stars){if(!gem.collected)drawGem(gem.x,gem.y+Math.sin(gem.bobOffset+frameCount*gem.bobSpeed)*3,gem.radius,gem.scale);} for(const pu of powerUps){if(pu && typeof pu.draw === 'function') pu.draw(ctx);} 
            for(const enemy of enemies){ 
                if (enemy.type === 'angler') drawAnglerFish(enemy); // Pass whole object for rotation
                else if (enemy.type === 'jellyfish') enemy.draw(ctx); 
            } 
            let pC1='#70C1FF',pC2='#2A7AB0'; if(player.speedBoost && Math.floor(player.speedBoostTimer / 5) % 2 === 0) {pC1='#98FB98';pC2='#3CB371';} if(player.invincibleTimer>0&&Math.floor(player.invincibleTimer/5)%2===0){pC1='#FFFACD';pC2='#FFD700';} if (player.temporaryDragTimer > 0 && Math.floor(player.temporaryDragTimer / 4) % 2 === 0) { pC1 = '#D1C4E9'; pC2 = '#9575CD';} drawCircleWithGradient(player.x,player.y,player.radius,pC1,pC2,player.scale); if (player.sonarPulseActive && player.sonarPulseRadius > 0) { ctx.strokeStyle = `rgba(200, 150, 255, ${0.6 * (player.sonarPulseTimer / (180/gameSpeedFactor))})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(player.x, player.y, player.sonarPulseRadius, 0, Math.PI * 2); ctx.stroke(); } if(player.isAttached&&player.attachedPlatform){ ctx.strokeStyle='rgba(220,240,255,0.4)';ctx.lineWidth=player.radius*0.12;ctx.beginPath();ctx.moveTo(player.x,player.y-player.radius);ctx.lineTo(player.x,player.attachedPlatform.y+player.attachedPlatform.height);ctx.stroke(); } else{ ctx.fillStyle='rgba(220,240,255,0.15)';ctx.beginPath();ctx.arc(player.x-player.radius*0.35,player.y-player.radius*0.35,player.radius*0.2,0,Math.PI*2);ctx.fill();} for(const p of gameEffectParticles){if(p&&typeof p.draw==='function')p.draw(ctx);} for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} const infoTxt=`Air: ${airCollected} | Depth: ${currentDepth}m | Bubbles: ${player.lives}`;ctx.fillStyle='white';ctx.strokeStyle='black';ctx.lineWidth=2.5;ctx.font='bold 17px Arial';ctx.textAlign='left';ctx.strokeText(infoTxt,10,30);ctx.fillText(infoTxt,10,30); }
        function drawStartScreen(){ /* ... (original) ... */ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} drawScreenMessage("ABYSSAL ASCENT","Press PUSH to Detach & Ascend",'#A7FFEB','white',30,18); ctx.font='bold 13px Arial';ctx.lineWidth=2;ctx.fillStyle='white';ctx.strokeStyle='black'; ctx.strokeText("Arrow Keys: Move Along Ceiling | SPACE/Button: PUSH Down",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+55); ctx.fillText("Arrow Keys: Move Along Ceiling | SPACE/Button: PUSH Down",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+55); ctx.strokeText("Collect Air Bubbles, reach the Surface Exit.",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+75); ctx.fillText("Collect Air Bubbles, reach the Surface Exit.",TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+75); for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);}  }
        function drawScreenMessage(title,msg,tc,mc,ts,ms){ /* ... (original) ... */ ctx.fillStyle=tc;ctx.strokeStyle='black';ctx.lineWidth=4;ctx.font=`bold ${ts}px Arial`;ctx.textAlign='center';ctx.strokeText(title,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2-25);ctx.fillText(title,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2-25);if(msg){ctx.fillStyle=mc;ctx.font=`bold ${ms}px Arial`;ctx.lineWidth=3;ctx.strokeText(msg,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+25);ctx.fillText(msg,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+25);}}
        function drawGameOverScreen(){ /* ... (original) ... */ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} drawScreenMessage("LOST TO THE ABYSS",`Total Air: ${gameOverFinalAir}`,'#FF8A80','white',36,22); ctx.fillStyle='white';ctx.strokeStyle='black';ctx.lineWidth=3;ctx.font='bold 24px Arial';ctx.textAlign='center'; ctx.strokeText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.fillText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.font='bold 19px Arial';ctx.strokeText('Press PUSH to Try Again',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); ctx.fillText('Press PUSH to Try Again',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);}  }
        function drawGameWonScreen(){ /* ... (original) ... */ drawBackground(); for(const b of ambientBubbles){if(b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);} drawScreenMessage("SURFACE REACHED!",`Total Air: ${airCollected}`,'#81C784','white',38,24); ctx.fillStyle='white';ctx.strokeStyle='black';ctx.lineWidth=3;ctx.font='bold 24px Arial';ctx.textAlign='center'; ctx.strokeText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.fillText(`Best Total Air: ${totalAirHighScore}`,TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+65); ctx.font='bold 19px Arial';ctx.strokeText('Press PUSH to Dive Again!',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); ctx.fillText('Press PUSH to Dive Again!',TARGET_CANVAS_WIDTH/2,TARGET_CANVAS_HEIGHT/2+105); for(const b of ambientBubbles){if(!b.isParallax&&b&&typeof b.draw==='function')b.draw(ctx);}  }
        function drawTransitionOverlay(){ /* ... (original) ... */ ctx.fillStyle=`rgba(0,5,10,${transitionAlpha})`;ctx.fillRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT);}
        function draw(){ /* ... (original draw states) ... */ if (gameState !== 'paused') { ctx.clearRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT); if(gameState==='start'){ drawStartScreen(); } else if(gameState==='playing'||gameState==='levelComplete'||gameState==='transitioning'){ drawGameElements(); } else if(gameState==='gameOver'){ drawGameOverScreen(); } else if(gameState==='gameWon'){ drawGameWonScreen(); } else { ctx.fillStyle='#AA0000';ctx.fillRect(0,0,TARGET_CANVAS_WIDTH,TARGET_CANVAS_HEIGHT); ctx.fillStyle='yellow';ctx.fillRect(20,20,60,60); ctx.fillStyle='white';ctx.font='14px Arial';ctx.fillText(`Unknown GS: ${gameState}`,20,100); console.error("DRAW IN UNKNOWN GAMESTATE:",gameState); } if (foregroundBubbles && foregroundBubbles.length > 0) { for (const b of foregroundBubbles) { if (b && typeof b.draw === 'function') b.draw(ctx); } } if(gameState==='transitioning'){ drawTransitionOverlay(); } } }
        function resetGame(isFullResetFromMenuOrGameOver = false){ /* ... (original resetGame, player states already included) ... */ if(isFullResetFromMenuOrGameOver){ player.lives=3;airCollected=0;currentDepth=STARTING_DEPTH;internalLevel=1; platformBaseSpeed = 0.42 * gameSpeedFactor; gradientBaseHue=200; player.radius=player.baseRadius;player.currentPushForce=PLAYER_BASE_PUSH_INITIAL; totalAirHighScore=parseInt(localStorage.getItem('abyssalAscentTotalAir_v14')||'0',10); } initLevel(isFullResetFromMenuOrGameOver); gameState='playing'; playerCanMove=true; player.canTakeDamage=true;clearTimeout(player.damageCooldownTimeout); player.invincible=false;player.invincibleTimer=0; player.speedBoost=false;player.speedBoostTimer=0; player.temporaryDragTimer = 0; player.sonarPulseActive = false; player.sonarPulseTimer = 0; transitionAlpha=0;transitionSpeed=Math.abs(transitionSpeed);transitionCallback=null; gameEffectParticles=[]; attemptPlayMusic(); updateUIVisibility(); gameOver=false; }
        let frameCount=0; function gameLoop(timestamp){ update(); draw(); frameCount++; requestAnimationFrame(gameLoop); }
        initLevel(true); prepareMusic(); updateUIVisibility(); gameLoop();
    </script>
</body>
</html>
